
---
title: 'Project GHI: Regenerative transcriptional states of the human epicardium: from foetus to adult and back again through single cell transcriptomics REVISION'
author: "Vincent Knight-Schrijver"
date: "`r format(Sys.time(), '%d %B %Y')`"


output:
 rmarkdown::pdf_document:
   includes:
     fig_caption: yes
     in_header: /home/vincent/Documents/documentation/RMD_materials/report_preamble.tex
urlcolor: blue
---
\sffamily
\renewcommand{\familydefault}{\sfdefault}
\addtolength{\headheight}{1.0cm}
\pagestyle{fancyplain}
\rhead{V. R. Knight-Schrijver  \includegraphics[width=0.2\linewidth]{/home/vincent/Documents/documentation/RMD_materials/header_logos.png}}
\renewcommand{\headrulewidth}{0pt}


# Introduction
This report is the beginning of a full running analysis of project GHI, detailing the workflow and results of the analysis. Project GHI is a combination 
of projects brought about firstly by G: the tentatively started project of Foetal heart scRNA-seq analysis which was a slow acquisition of 
foetal samples, followed by Project H, the apparent need to automatically annotate these samples using a single-cell classification model, and 
galvanised by project I, the sudden appearance of an adult dataset with identifiable scRNA-seq epicardium. This led to the natural questions:

1. How does foetal epicardium differ from adult epicardium in normal conditions and otherwise healthy ageing?
2. Is there a signal here responsible for the perceived regenerative potential of hearts in more embryonic and neonatal stages of mammals?
3. How does the adult epicardium compare with our in vitro hESC-derived epicardium?

There are multiple sub-questions but we come to discuss this throughout the work here. Let us begin. For reference, data are often saved used the function **saveRDS()**. 
In this workflow I pointed the destination directory as **script.dir**. This is a custom object set up at the start of each script and can be found by following 
the output directory of the project and then the subdirectory named after the script. In this report, headings of sections are named after scripts for ease.

\scriptsize
```{r, echo = F}
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=80),tidy=F,strip.white=F)
```

\scriptsize
```{r, message = F}
source("config.r")
library(rmarkdown)
    GetPackages=F
source("scripts/packages.r")
```

# Workflow and analysis structure:

The first thing we do is load our datasets. The adult dataset was taken from the Heart Cell Atlas (2020) but was sampled to only include donors 
which contained epicardial single-cell data. This was determined using the explorer / visualisation provided on the HCA website using 
cellxgene. Then we use a python script to parse the global dataset and pull out these donors separately, filtering by cell data only (as opposed 
to nuclei). Then the new dataset subset is written out into an accepted h5ad format for conversion into a Seurat object in R. This code chunk
is explicitly in python and takes places in the subdirectory /HCA2020.

\scriptsize
```{py, eval=F, message=F, echo=T, tidy=T}
# PYTHON3
  python3

# import modules
import numpy as np
import pandas as pd
import scanpy as sc
import statistics
from statistics import stdev
from matplotlib import pyplot as plt



# PRE PRE 
hca2020 = sc.read_h5ad("global_raw.h5ad")

# identify and subset source (cells) only
hca2020_cells = hca2020[hca2020.obs.source == "Cells"]

# identify and subset donors by epi donors only
# subset by donor ID
hca2020_cells_donor = hca2020_cells[hca2020_cells.obs.donor.isin(["D3", "D4", "D5", "D6", "D7"])]

# This brings us to around 37000 cells - more than small enough to start wrangling in 
# R or so as part of a Seurat package!? Check here - we have all meso cells
hca2020_cells_donor[hca2020_cells_donor.obs.cell_type == "Mesothelial"]

# h5AD Save? We must first pass as LOOM because of Seurat miscompatability
hca2020_cells_donor.write_loom("Donor_sample_matched_global_raw.loom")


exit()

#### QUIT PYTHON AND RUN::
# downgrade anndata to  < 7
  sudo pip3 install anndata==0.6.22.post1

# PYTHON3
  python3
 
# import modules
import numpy as np
import pandas as pd
import scanpy as sc
import statistics
from statistics import stdev
from matplotlib import pyplot as plt

 # LOOM READ?
hca2020_cells_donor = sc.read_loom("Donor_sample_matched_global_raw.loom")

# h5AD Save?
hca2020_cells_donor.write_h5ad("Donor_sample_matched_global_raw_anndata6.h5ad")

# export obs
hca2020_cells_donor.obs.to_csv("hca2020_obs.csv")

exit()
#### QUIT PYTHON AND RUN::
# reinstall the current and correct version of anndata for quick processing
  sudo pip3 install anndata==0.7rc2

```
\normalsize


The steps above are necessary to ensure that the h5ad file is suitable for Seurat to read in as there are noted problems in this process when 
using the latest version of anndata. Hence, we need to export as an intermediary file, installing an older version of anndata, read 
the loom file into python, and only then export as a h5ad alongside obs.csv object for data and observables respectively. We are then
able to load the file into R.

<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
```{r, eval=T, message=F, echo=F}
if(!exists("HCA_init")){  
  HCA_init <- ReadH5AD("HCA2020/Donor_sample_matched_global_raw_anndata6.h5ad")
  HCA.obs <- read.csv("HCA2020/hca2020_obs.csv", head=T, row.names=1)
  colnames(HCA.obs) <- gsub("_", "\\.", colnames(HCA.obs))
    for(
      obs in colnames(HCA.obs)[
        sapply(1:length(HCA.obs), function(i){class(HCA.obs[,i])})=="character"
      ]
    ){
      HCA_init[[obs]] <- as.factor(HCA.obs[,obs])
    }
  Idents(HCA_init) <- HCA_init$cell.type
  HCA_init$stage = "adult"
  HCA_init$nFeature_RNA = HCA_init$nFeatures_RNA
  }


```
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
######################################################
# read our data with the following script
######################################################
version.source("scripts/read_data.r", 1)
######################################################
## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## 

## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## 
# ADULT data - extracted from the h5ad on HeartCellAtlas
# filtered to include only cells, > donors "D3","D4", "d5", "D6", "d7"
  HCA_init <- ReadH5AD("HCA2020/Donor_sample_matched_global_raw_anndata6.h5ad")
  HCA.obs <- read.csv("HCA2020/hca2020_obs.csv", head=T, row.names=1)
# Re-label the colnames of obs where "_".  
  colnames(HCA.obs) <- gsub("_", "\\.", colnames(HCA.obs))
# Re-order all and apply as factor in order...  
    for(
      obs in colnames(HCA.obs)[
        sapply(1:length(HCA.obs), function(i){class(HCA.obs[,i])})=="character"
      ]
    ){
      HCA_init[[obs]] <- as.factor(HCA.obs[,obs])
    }
# Assign cell.type as Identifiers    
  Idents(HCA_init) <- HCA_init$cell.type
# Add stage meta  
  HCA_init$stage = "adult"
# relabel n Features for sanity
  HCA_init$nFeature_RNA = HCA_init$nFeatures_RNA
  
  
```
\normalsize

We then load in the foetal datasets, these were the samples dissected and prepared by Hongorzul Davaapil in the Sinha lab. Libraries were
prepared and sequencing was carried out at the CRUK facilities in Cambridge, UK. We have 6 samples in this dataset which were sequenced
in two rounds. First round was carried out in November 2020. The second round was carried out in January 2021.


\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
 
## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## 
# Foetal data - from our 10x V3 samples @ Nov 2020
  BRC2251 <- Read10X(data.dir = "/mnt/LocalHDD/raw_data/G_Fetal_hearts/BRC2251_heart/outs/filtered_feature_bc_matrix") 
  BRC2252 <- Read10X(data.dir = "/mnt/LocalHDD/raw_data/G_Fetal_hearts/BRC2252_heart/outs/filtered_feature_bc_matrix")
  BRC2256 <- Read10X(data.dir = "/mnt/LocalHDD/raw_data/G_Fetal_hearts/BRC2256_heart/outs/filtered_feature_bc_matrix")
  BRC2260 <- Read10X(data.dir = "/mnt/LocalHDD/raw_data/G_Fetal_hearts/BRC2260_heart/outs/filtered_feature_bc_matrix")
  BRC2262 <- Read10X(data.dir = "/mnt/LocalHDD/raw_data/G_Fetal_hearts/BRC2262_heart/outs/filtered_feature_bc_matrix")
  BRC2263 <- Read10X(data.dir = "/mnt/LocalHDD/raw_data/G_Fetal_hearts/BRC2263_heart/outs/filtered_feature_bc_matrix")
  
# Genes / Features...
  BRC2251.genes = read.csv(
    "/mnt/LocalHDD/raw_data/G_Fetal_hearts/BRC2251_heart/outs/filtered_feature_bc_matrix/features.tsv.gz", 
    head=F, sep="\t", stringsAsFactors=F
  ) 
  BRC2252.genes = read.csv(
    "/mnt/LocalHDD/raw_data/G_Fetal_hearts/BRC2252_heart/outs/filtered_feature_bc_matrix/features.tsv.gz", 
    head=F, sep="\t", stringsAsFactors=F
  ) 
  BRC2256.genes = read.csv(
    "/mnt/LocalHDD/raw_data/G_Fetal_hearts/BRC2256_heart/outs/filtered_feature_bc_matrix/features.tsv.gz", 
    head=F, sep="\t", stringsAsFactors=F
  ) 
  BRC2260.genes = read.csv(
    "/mnt/LocalHDD/raw_data/G_Fetal_hearts/BRC2260_heart/outs/filtered_feature_bc_matrix/features.tsv.gz", 
    head=F, sep="\t", stringsAsFactors=F
  ) 
  BRC2262.genes = read.csv(
    "/mnt/LocalHDD/raw_data/G_Fetal_hearts/BRC2262_heart/outs/filtered_feature_bc_matrix/features.tsv.gz", 
    head=F, sep="\t", stringsAsFactors=F
  ) 
  BRC2263.genes = read.csv(
    "/mnt/LocalHDD/raw_data/G_Fetal_hearts/BRC2263_heart/outs/filtered_feature_bc_matrix/features.tsv.gz", 
    head=F, sep="\t", stringsAsFactors=F
  ) 

# Edit.genes for similarity...
  # We can see that they're highly similar... Using the same version of cellranger.. so all is OK!!!
  # We find that the only difference was a "-" to "." 
  # conversion probably carried out by a make.names() function
  data.frame(rownames(BRC2252), rownames(HCA_init))[which(rownames(BRC2252) != rownames(HCA_init)),]
# Here we replace the rownames in foetal samples with adult rownames  
  rownames(BRC2251) = rownames(HCA_init)
  rownames(BRC2252) = rownames(HCA_init)
  rownames(BRC2256) = rownames(HCA_init)
  rownames(BRC2260) = rownames(HCA_init)
  rownames(BRC2262) = rownames(HCA_init)
  rownames(BRC2263) = rownames(HCA_init)

```
\normalsize

<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->

```{r, eval=F, message=F, echo=F}
 data.frame(rownames(BRC2252), rownames(HCA_init))[which(rownames(BRC2252) != rownames(HCA_init)),]

```
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->

Our 7th foetal sample (F5 in publication) was the epicardium-enriched sample taken by Alexander Ross from the Vallier lab.
These samples were acquired in 2018 and were preliminarily analysed for epicardial cells - unfortunately hindered by the small
number of cells within the sample and in fact, within all heart samples.


\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
           
## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## 
# AlexSC data
                                               
######################################################
######################################################
######################################################
# Let us take our AlexSC Data from 10x V2 @ 2018?
  alexsc <- Read10X(data.dir = "~/Documents/Projects/D_AlexSC/data/Alex10X/")
  alexsc.genes <- read.csv("~/Documents/Projects/D_AlexSC/data/Alex10X/genes.tsv", head=F, sep="\t", stringsAsFactors=F)

# Challenge.. only 65% of features are shared... the alexsc datset was generated a while ago.. 
# let's update this if possible.
  sum(rownames(alexsc) %in% rownames(BRC2251)) / dim(alexsc)[1] * 100
  
\scriptsize
```{r, eval=F, message=F, echo=F, tidy=F}
  sum(rownames(alexsc) %in% rownames(BRC2251)) / dim(alexsc)[1] * 100
  
  
```  
\normalsize

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}

# We need to clean the rownames. 
# It's irritating to find duplicate rownames and ensembl genes that don't map etc.
# Update them using our function 
# Search for the ensemblID in the MART biomart....
  library(biomaRt)
  library(extraDistr)
## grab a mart...  
  mart <<- useMart("ensembl",  "hsapiens_gene_ensembl")
# Create a mapping table
  label.df <<- getBM(mart=mart, 
                 attributes=c("ensembl_gene_id", 
                              "external_gene_name", 
                              "hgnc_symbol", 
                              "chromosome_name", 
                              "external_synonym"), 
                 useCache=F
               )

# Inputs:
#  Dataframe of ENSID and gene symbol
   input.df <- alexsc.genes
   
# take ensembl IDs
   ensg <- input.df[,1]

# The first thing we want to do is to update all current gene names...
# "SCO2" for example
  # Firstly, we will generate a new list of gene names from the matching ensemblIDs
    new.genes <- character(length(input.df[,1]))

# all NAs (not mappable ENSGids????????? What is going one here?)
    ensg.na =  which(is.na(match(ensg, label.df$ensembl_gene_id)))
    ensg.not.na =  which(!is.na(match(ensg, label.df$ensembl_gene_id)))
# Matching up the EnsID with those from BioMaRt and then taking only the new external name column...
    new.genes[ensg.not.na] <- label.df[na.omit(match(ensg, label.df$ensembl_gene_id)),"external_gene_name"]
    
  # updating the genes with the most recent HGNC symbol?
    new.genes[ensg.na] = update.genes(input.df[ensg.na,2])
 
  # duplicates...
    dup.genes = new.genes[duplicated(new.genes)]
```
\normalsize

<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
```{r, eval=F, message=F, echo=F}
 # For reference... those which are duplicated...
    head(data.frame(input.df, new.genes)[new.genes %in% dup.genes,])
```
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}

  # For reference... those which are duplicated...
    head(data.frame(input.df, new.genes)[new.genes %in% dup.genes,])
  # Output:
    rownames(alexsc) = new.genes
    
    
```
\normalsize
# Processing data
We being with processing the data and trying to do so in an equal fashion across all samples. For all samples we will attempt to carry out the following:

1. Remove bad cells
2. Remove uninformative genes

To do so we first have a look at the processing done to the human adult samples from the HCA. 
We see that there are some clear thresholds applied - for example the maximum reads in the HCA datasets was 15,000.
To keep as much uniformity between datasets as possible, we apply the same threshold across all foetal samples. I also
apply a lower threshold to remove all cells with fewer than 1000 UMIs.

<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
```{r, eval=T, message=F, echo=F}
  range(HCA_init$nCount_RNA)
  range(HCA_init$nFeatures_RNA)
```
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# Check range of key cell QC metrics:
  range(HCA_init$nCount_RNA)
  range(HCA_init$nFeatures_RNA)
# It appears as though they have cut all cells above 15,000 reads
  
# Adult data
# Cut it by the same feature count...
  HCA_init <- subset(HCA_init, cells = colnames(HCA_init)[HCA_init$nFeatures_RNA >= 300])
# Cut by an arbitrary minimum reads counts
  HCA_init <- subset(HCA_init, cells = colnames(HCA_init)[HCA_init$nCount_RNA >= 1000])

# Stick into another Seurat object for now
  HCA.so <- HCA_init

```

## Foetal preprocessing
Now with the foetal datasets we dive into a very large section of the script in pre-processing. Firstly, remove any 
duplicated genes - summing the rows when found. Then we'll treat the samples indivicually, cutting down the cells 
based on QC thresholds. There are only seven samples, it's fine to copy and paste the code and just replace the 
object names; for more samples than this I would consider loading data into a list object and applying across.


\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}

## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##   
# Remove /  aggregate duplicate genes...
  BRC2251 <- Matrix::Matrix(aggregate.duplicate.genes(as.matrix(BRC2251)))
  BRC2252 <- Matrix::Matrix(aggregate.duplicate.genes(as.matrix(BRC2252)))
  BRC2256 <- Matrix::Matrix(aggregate.duplicate.genes(as.matrix(BRC2256)))
  BRC2260 <- Matrix::Matrix(aggregate.duplicate.genes(as.matrix(BRC2260)))
  BRC2262 <- Matrix::Matrix(aggregate.duplicate.genes(as.matrix(BRC2262)))
  BRC2263 <- Matrix::Matrix(aggregate.duplicate.genes(as.matrix(BRC2263)))
  BRC2256 <- Matrix::Matrix(aggregate.duplicate.genes(as.matrix(BRC2256)))
  gc()


## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##  
# Cut down bad cells...  

#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  
# BRC2251
  # Cell QC and processing
    # Reads in cells  
     nReads <- colSums(BRC2251)
    # cell gene expressions
     nGenes <- colSums(BRC2251 > 0)
    # Mitochondrial Gene expression
     mito.genes <- grep(pattern = "^MT-", rownames(BRC2251))
     nMito <- colSums(BRC2251[mito.genes,])/nReads*100
    # Top influencial genes as cell reads fraction?
      g.influencial.50 <- colSums(BRC2251[order(-rowSums(BRC2251))[1:50],]) / nReads * 100
    # Quality control data.frame  
      QC.df <- data.frame("nReads"=normalise(log(nReads+1)), # total reads QC
                        "nGenes"=normalise(log(nGenes+1)), # Features QC
                        "percent.mito "=normalise(log(nMito+1)), # Erroneous feature enrichment
                        "%.reads.in.top.50.exp.genes"=normalise(log(g.influencial.50+1)) # Fraction of reads in top abundance genes
                        )
                  
     QC.PCA <- prcomp(QC.df)
  # SCoring   
     QC.df$QC.score = rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])
     QC.df$rank = order(-QC.df$QC.score)

  # Plots   
   par(mfrow=c(3,3), mar=c(4,4,3,0.2))  
  # Low nReads
    plot(nReads,nGenes)
    
  # Low gene expression - remove below 
    plot(log(nGenes)); abline(h=log(300))

  # High mitochondrial mRNA - remove above 10%
    plot(nMito); abline(h=15)

    cMito = nMito > 15
    cGenes = nGenes < 300
    cReads = nReads < 1000 | nReads > 15000
    BRC2251.cells2remove = (cMito | cGenes | cReads)
    
  # QC plots covering the QC parameters
    for(i in 1:4){
      plot(QC.PCA$x[,1], QC.PCA$x[,2], col=plotcols(QC.df[,i]), main=colnames(QC.df)[i], pch=16)
    }
  # and sum of QC criteria (good - bad)
    plot(QC.PCA$x[,1:2], col=plotcols(rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])), main="QC.score", pch=16)
  # overlay of the successful cells
    points(QC.PCA$x[,1:2], col=(0:1)[as.factor(QC.df$QC.score > 0)], main="Failure.criteria", pch=16, cex=0.6)          
  # Using the thresholds applied to all datasets showing the cells removed      
    plot(QC.PCA$x[,1:2], col=as.factor(BRC2251.cells2remove), main="cells removed (red)", pch=16)
  
  # Matrix cut
    BRC2251.cut <- BRC2251[,!BRC2251.cells2remove]
    
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #      
# BRC2252
  # Cell QC and processing
    # Reads in cells  
     nReads <- colSums(BRC2252)
    # cell gene expressions
     nGenes <- colSums(BRC2252 > 0)
    # Mitochondrial Gene expression
     mito.genes <- grep(pattern = "^MT-", rownames(BRC2252))
     nMito <- colSums(BRC2252[mito.genes,])/nReads*100
    # Top influencial genes as cell reads fraction?
      g.influencial.50 <- colSums(BRC2252[order(-rowSums(BRC2252))[1:50],]) / nReads * 100
    # Quality control data.frame  
      QC.df <- data.frame("nReads"=normalise(log(nReads+1)), # total reads QC
                        "nGenes"=normalise(log(nGenes+1)), # Features QC
                        "percent.mito "=normalise(log(nMito+1)), # Erroneous feature enrichment
                        "%.reads.in.top.50.exp.genes"=normalise(log(g.influencial.50+1)) # Fraction of reads in top abundance genes
                        )
                  
     QC.PCA <- prcomp(QC.df)
  # SCoring   
     QC.df$QC.score = rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])
     QC.df$rank = order(-QC.df$QC.score)

  # Plots   
    par(mfrow=c(3,3), mar=c(4,4,3,0.2))  
  # Low nReads
    plot(nReads,nGenes)
    
  # Low gene expression - remove below 
    plot(log(nGenes)); abline(h=log(300))

  # High mitochondrial mRNA - remove above 10%
    plot(nMito); abline(h=15)

    cMito = nMito > 15
    cGenes = nGenes < 300
    cReads = nReads < 1000 | nReads > 15000
    BRC2252.cells2remove = (cMito | cGenes | cReads)
   
  # QC plots covering the QC parameters
    for(i in 1:4){
      plot(QC.PCA$x[,1], QC.PCA$x[,2], col=plotcols(QC.df[,i]), main=colnames(QC.df)[i], pch=16)
    }
  # and sum of QC criteria (good - bad)
    plot(QC.PCA$x[,1:2], col=plotcols(rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])), main="QC.score", pch=16)
  # overlay of the successful cells
    points(QC.PCA$x[,1:2], col=(0:1)[as.factor(QC.df$QC.score > 0)], main="Failure.criteria", pch=16, cex=0.6)          
  # Using the thresholds applied to all datasets showing the cells removed      
    plot(QC.PCA$x[,1:2], col=as.factor(BRC2251.cells2remove), main="cells removed (red)", pch=16)
  
  # Matrix cut
    BRC2252.cut <- BRC2252[,!BRC2252.cells2remove]
      
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #      
# BRC2256
  # Cell QC and processing
    # Reads in cells  
     nReads <- colSums(BRC2256)
    # cell gene expressions
     nGenes <- colSums(BRC2256 > 0)
    # Mitochondrial Gene expression
     mito.genes <- grep(pattern = "^MT-", rownames(BRC2256))
     nMito <- colSums(BRC2256[mito.genes,])/nReads*100
    # Top influencial genes as cell reads fraction?
      g.influencial.50 <- colSums(BRC2256[order(-rowSums(BRC2256))[1:50],]) / nReads * 100
    # Quality control data.frame  
      QC.df <- data.frame("nReads"=normalise(log(nReads+1)), # total reads QC
                        "nGenes"=normalise(log(nGenes+1)), # Features QC
                        "percent.mito "=normalise(log(nMito+1)), # Erroneous feature enrichment
                        "%.reads.in.top.50.exp.genes"=normalise(log(g.influencial.50+1)) # Fraction of reads in top abundance genes
                        )
                  
     QC.PCA <- prcomp(QC.df)
  # SCoring   
     QC.df$QC.score = rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])
     QC.df$rank = order(-QC.df$QC.score)

  # Plots   
   par(mfrow=c(3,3), mar=c(4,4,3,0.2))  
  # Low nReads
    plot(nReads,nGenes)
    
  # Low gene expression - remove below 
    plot(log(nGenes)); abline(h=log(300))

  # High mitochondrial mRNA - remove above 10%
    plot(nMito); abline(h=15)

    cMito = nMito > 15
    cGenes = nGenes < 300
    cReads = nReads < 1000 | nReads > 15000
    BRC2256.cells2remove = (cMito | cGenes | cReads)
    
  # QC plots covering the QC parameters
    for(i in 1:4){
      plot(QC.PCA$x[,1], QC.PCA$x[,2], col=plotcols(QC.df[,i]), main=colnames(QC.df)[i], pch=16)
    }
  # and sum of QC criteria (good - bad)
    plot(QC.PCA$x[,1:2], col=plotcols(rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])), main="QC.score", pch=16)
  # overlay of the successful cells
    points(QC.PCA$x[,1:2], col=(0:1)[as.factor(QC.df$QC.score > 0)], main="Failure.criteria", pch=16, cex=0.6)          
  # Using the thresholds applied to all datasets showing the cells removed      
    plot(QC.PCA$x[,1:2], col=as.factor(BRC2251.cells2remove), main="cells removed (red)", pch=16)
  
  # Matrix cut
    BRC2256.cut <- BRC2256[,!BRC2256.cells2remove]
      
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #      
# BRC2260
  # Cell QC and processing
    # Reads in cells  
     nReads <- colSums(BRC2260)
    # cell gene expressions
     nGenes <- colSums(BRC2260 > 0)
    # Mitochondrial Gene expression
     mito.genes <- grep(pattern = "^MT-", rownames(BRC2260))
     nMito <- colSums(BRC2260[mito.genes,])/nReads*100
    # Top influencial genes as cell reads fraction?
      g.influencial.50 <- colSums(BRC2260[order(-rowSums(BRC2260))[1:50],]) / nReads * 100
    # Quality control data.frame  
      QC.df <- data.frame("nReads"=normalise(log(nReads+1)), # total reads QC
                        "nGenes"=normalise(log(nGenes+1)), # Features QC
                        "percent.mito "=normalise(log(nMito+1)), # Erroneous feature enrichment
                        "%.reads.in.top.50.exp.genes"=normalise(log(g.influencial.50+1)) # Fraction of reads in top abundance genes
                        )
                  
     QC.PCA <- prcomp(QC.df)
  # SCoring   
     QC.df$QC.score = rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])
     QC.df$rank = order(-QC.df$QC.score)

  # Plots   
   par(mfrow=c(3,3), mar=c(4,4,3,0.2))  
  # Low nReads
    plot(nReads,nGenes)
    
  # Low gene expression - remove below 
    plot(log(nGenes)); abline(h=log(300))

  # High mitochondrial mRNA - remove above 10%
    plot(nMito); abline(h=15)

    cMito = nMito > 15
    cGenes = nGenes < 300
    cReads = nReads < 1000 | nReads > 15000
    BRC2260.cells2remove = (cMito | cGenes | cReads)
    
  # QC plots covering the QC parameters
    for(i in 1:4){
      plot(QC.PCA$x[,1], QC.PCA$x[,2], col=plotcols(QC.df[,i]), main=colnames(QC.df)[i], pch=16)
    }
  # and sum of QC criteria (good - bad)
    plot(QC.PCA$x[,1:2], col=plotcols(rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])), main="QC.score", pch=16)
  # overlay of the successful cells
    points(QC.PCA$x[,1:2], col=(0:1)[as.factor(QC.df$QC.score > 0)], main="Failure.criteria", pch=16, cex=0.6)          
  # Using the thresholds applied to all datasets showing the cells removed      
    plot(QC.PCA$x[,1:2], col=as.factor(BRC2251.cells2remove), main="cells removed (red)", pch=16)
  
  # Matrix cut
    BRC2260.cut <- BRC2260[,!BRC2260.cells2remove]
      
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #      
# BRC2262
  # Cell QC and processing
    # Reads in cells  
     nReads <- colSums(BRC2262)
    # cell gene expressions
     nGenes <- colSums(BRC2262 > 0)
    # Mitochondrial Gene expression
     mito.genes <- grep(pattern = "^MT-", rownames(BRC2262))
     nMito <- colSums(BRC2262[mito.genes,])/nReads*100
    # Top influencial genes as cell reads fraction?
      g.influencial.50 <- colSums(BRC2262[order(-rowSums(BRC2262))[1:50],]) / nReads * 100
    # Quality control data.frame  
      QC.df <- data.frame("nReads"=normalise(log(nReads+1)), # total reads QC
                        "nGenes"=normalise(log(nGenes+1)), # Features QC
                        "percent.mito "=normalise(log(nMito+1)),  # Erroneous feature enrichment
                        "%.reads.in.top.50.exp.genes"=normalise(log(g.influencial.50+1)) # Fraction of reads in top abundance genes 
                        )
                  
     QC.PCA <- prcomp(QC.df)
  # SCoring   
     QC.df$QC.score = rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])
     QC.df$rank = order(-QC.df$QC.score)

  # Plots   
   par(mfrow=c(3,3), mar=c(4,4,3,0.2))  
  # Low nReads
    plot(nReads,nGenes)
    
  # Low gene expression - remove below 
    plot(log(nGenes)); abline(h=log(300))

  # High mitochondrial mRNA - remove above 10%
    plot(nMito); abline(h=15)

    cMito = nMito > 15
    cGenes = nGenes < 300
    cReads = nReads < 1000 | nReads > 15000
    BRC2262.cells2remove = (cMito | cGenes | cReads)
   
  # QC plots covering the QC parameters
    for(i in 1:4){
      plot(QC.PCA$x[,1], QC.PCA$x[,2], col=plotcols(QC.df[,i]), main=colnames(QC.df)[i], pch=16)
    }
  # and sum of QC criteria (good - bad)
    plot(QC.PCA$x[,1:2], col=plotcols(rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])), main="QC.score", pch=16)
  # overlay of the successful cells
    points(QC.PCA$x[,1:2], col=(0:1)[as.factor(QC.df$QC.score > 0)], main="Failure.criteria", pch=16, cex=0.6)          
  # Using the thresholds applied to all datasets showing the cells removed      
    plot(QC.PCA$x[,1:2], col=as.factor(BRC2251.cells2remove), main="cells removed (red)", pch=16)
   
  # Matrix cut
    BRC2262.cut <- BRC2262[,!BRC2262.cells2remove]
      
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #      
# BRC2263
  # Cell QC and processing
    # Reads in cells  
     nReads <- colSums(BRC2263)
    # cell gene expressions
     nGenes <- colSums(BRC2263 > 0)
    # Mitochondrial Gene expression
     mito.genes <- grep(pattern = "^MT-", rownames(BRC2263))
     nMito <- colSums(BRC2263[mito.genes,])/nReads*100
    # Top influencial genes as cell reads fraction?
      g.influencial.50 <- colSums(BRC2263[order(-rowSums(BRC2263))[1:50],]) / nReads * 100
    # Quality control data.frame  
      QC.df <- data.frame("nReads"=normalise(log(nReads+1)), # total reads QC
                        "nGenes"=normalise(log(nGenes+1)), # Features QC
                        "percent.mito "=normalise(log(nMito+1)),  # Erroneous feature enrichment
                        "%.reads.in.top.50.exp.genes"=normalise(log(g.influencial.50+1)) # Fraction of reads in top abundance genes  
                        )
                  
     QC.PCA <- prcomp(QC.df)
  # SCoring   
     QC.df$QC.score = rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])
     QC.df$rank = order(-QC.df$QC.score)

  # Plots   
   par(mfrow=c(3,3), mar=c(4,4,3,0.2))  
  # Low nReads
    plot(nReads,nGenes)
    
  # Low gene expression - remove below 
    plot(log(nGenes)); abline(h=log(300))

  # High mitochondrial mRNA - remove above 10%
    plot(nMito); abline(h=15)

    cMito = nMito > 15
    cGenes = nGenes < 300
    cReads = nReads < 1000 | nReads > 15000
    BRC2263.cells2remove = (cMito | cGenes | cReads)
   
  # QC plots covering the QC parameters
    for(i in 1:4){
      plot(QC.PCA$x[,1], QC.PCA$x[,2], col=plotcols(QC.df[,i]), main=colnames(QC.df)[i], pch=16)
    }
  # and sum of QC criteria (good - bad)
    plot(QC.PCA$x[,1:2], col=plotcols(rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])), main="QC.score", pch=16)
  # overlay of the successful cells
    points(QC.PCA$x[,1:2], col=(0:1)[as.factor(QC.df$QC.score > 0)], main="Failure.criteria", pch=16, cex=0.6)          
  # Using the thresholds applied to all datasets showing the cells removed      
    plot(QC.PCA$x[,1:2], col=as.factor(BRC2251.cells2remove), main="cells removed (red)", pch=16)
   
  # Matrix cut
    BRC2263.cut <- BRC2263[,!BRC2263.cells2remove]
      
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #      
# alexsc
  # Cell QC and processing
    # Reads in cells  
     nReads <- colSums(alexsc)
    # cell gene expressions
     nGenes <- colSums(alexsc > 0)
    # Mitochondrial Gene expression
     mito.genes <- grep(pattern = "^MT-", rownames(alexsc))
     nMito <- colSums(alexsc[mito.genes,])/nReads*100
    # Top influencial genes as cell reads fraction?
      g.influencial.50 <- colSums(alexsc[order(-rowSums(alexsc))[1:50],]) / nReads * 100
    # Quality control data.frame  
      QC.df <- data.frame("nReads"=normalise(log(nReads+1)), # total reads QC
                        "nGenes"=normalise(log(nGenes+1)), # Features QC
                        "percent.mito "=normalise(log(nMito+1)), # Erroneous feature enrichment
                        "%.reads.in.top.50.exp.genes"=normalise(log(g.influencial.50+1)) # Fraction of reads in top abundance genes  
                        )
                  
     QC.PCA <- prcomp(QC.df)
  # SCoring   
     QC.df$QC.score = rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])
     QC.df$rank = order(-QC.df$QC.score)

  # Plots   
   par(mfrow=c(3,3), mar=c(4,4,3,0.2))  
  # Low nReads
    plot(nReads,nGenes)
    
  # Low gene expression - remove below 
    plot(log(nGenes)); abline(h=log(300))

  # High mitochondrial mRNA - remove above 10%
    plot(nMito); abline(h=15)

    cMito = nMito > 15
    cGenes = nGenes < 300
    cReads = nReads < 1000 | nReads > 15000
    alexsc.cells2remove = (cMito | cGenes | cReads)
   
  # QC plots covering the QC parameters
    for(i in 1:4){
      plot(QC.PCA$x[,1], QC.PCA$x[,2], col=plotcols(QC.df[,i]), main=colnames(QC.df)[i], pch=16)
    }
  # and sum of QC criteria (good - bad)
    plot(QC.PCA$x[,1:2], col=plotcols(rowSums(QC.df[,1:2])-rowSums(QC.df[,3:4])), main="QC.score", pch=16)
  # overlay of the successful cells
    points(QC.PCA$x[,1:2], col=(0:1)[as.factor(QC.df$QC.score > 0)], main="Failure.criteria", pch=16, cex=0.6)          
  # Using the thresholds applied to all datasets showing the cells removed      
    plot(QC.PCA$x[,1:2], col=as.factor(BRC2251.cells2remove), main="cells removed (red)", pch=16)
   
  # Matrix cut
    alexsc.cut <- alexsc[,!alexsc.cells2remove]
      
```
\normalsize


\scriptsize
```{r, echo=F, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{fig1} BRC2252 Quality control showing; A, log genes expressed vs UMIs; B, genes expressed; C, mitochondrial genes; D-I, PCA plots with reads, features, mito \\%, reads in high-abundance genes, overall QC score, and final cut"}
knitr::include_graphics("output/v_2/preprocess/figures/BRC2251_QC_initial.pdf")
```
\normalsize
\scriptsize
```{r, echo=F, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{fig2} BRC2252 Quality control showing; A, log genes expressed vs UMIs; B, genes expressed; C, mitochondrial genes; D-I, PCA plots with reads, features, mito \\%, reads in high-abundance genes, overall QC score, and final cut"}
knitr::include_graphics("output/v_2/preprocess/figures/BRC2252_QC_initial.pdf")
```
\normalsize
\scriptsize
```{r, echo=F, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{fig3} BRC2253 Quality control showing; A, log genes expressed vs UMIs; B, genes expressed; C, mitochondrial genes; D-I, PCA plots with reads, features, mito \\%, reads in high-abundance genes, overall QC score, and final cut"}
knitr::include_graphics("output/v_2/preprocess/figures/BRC2256_QC_initial.pdf")
```
\normalsize
\scriptsize
```{r, echo=F, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{fig4} BRC2254 Quality control showing; A, log genes expressed vs UMIs; B, genes expressed; C, mitochondrial genes; D-I, PCA plots with reads, features, mito \\%, reads in high-abundance genes, overall QC score, and final cut"}
knitr::include_graphics("output/v_2/preprocess/figures/BRC2260_QC_initial.pdf")
```
\normalsize
\scriptsize
```{r, echo=F, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{fig5} BRC2255 Quality control showing; A, log genes expressed vs UMIs; B, genes expressed; C, mitochondrial genes; D-I, PCA plots with reads, features, mito \\%, reads in high-abundance genes, overall QC score, and final cut"}
knitr::include_graphics("output/v_2/preprocess/figures/BRC2262_QC_initial.pdf")
```
\normalsize
\scriptsize
```{r, echo=F, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{fig6} BRC2256 Quality control showing; A, log genes expressed vs UMIs; B, genes expressed; C, mitochondrial genes; D-I, PCA plots with reads, features, mito \\%, reads in high-abundance genes, overall QC score, and final cut"}
knitr::include_graphics("output/v_2/preprocess/figures/BRC2263_QC_initial.pdf")
```
\normalsize
\scriptsize
```{r, echo=F, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{fig7} BRC2257 Quality control showing; A, log genes expressed vs UMIs; B, genes expressed; C, mitochondrial genes; D-I, PCA plots with reads, features, mito \\%, reads in high-abundance genes, overall QC score, and final cut"}
knitr::include_graphics("output/v_2/preprocess/figures/alexsc_QC_initial.pdf")
```
\normalsize



# Heart cell classification
Before compiling the data into Seurat objects, we can apply our heart cell classifier to our raw data output from cellranger. 
To do this we take the UMI matrices and transform them into gene frequency matrices as this was the variable type used to train the model. 
Then we build gene-expression probability matrices for each class which determines the likelihood that the observed gene expression is found in 
a cell belonging to that class. Finally, we make predictions of the classifier by taking the product sum of the posterior likelihoods and the prior estimate
in each cell for each class. The highest probabilty class for each cell is determined which annotates the cell. For further context of this code, we 
have large run times and save each matrix as an R object after each sample. We load these in afterwards to regulate the RAM usage.

## Load the model
\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# HCC and cell type prediction  
# load the model
  model <- readRDS("~/Documents/Projects/H_Heart_classification/tf_model.rds")
  nbc.model = model$models$nbc.model.rfgenes

```  

## Create UMI frequencies 
\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# Create UMI frequencies 
  tf.1 <- t(t(BRC2251) / colSums(BRC2251))
  
  tf.2 <- t(t(BRC2252) / colSums(BRC2252))

  tf.3 <- t(t(BRC2256) / colSums(BRC2256))
  
  tf.4 <- t(t(BRC2260) / colSums(BRC2260))
  
  tf.5 <- t(t(BRC2262) / colSums(BRC2262))
  
  tf.6 <- t(t(BRC2263) / colSums(BRC2263))
  
  tf.7 <- t(t(alexsc) / colSums(alexsc))
  
  tf.8 <- t(t(GetAssayData(HCA_init, slot="counts")) / 
            colSums(GetAssayData(HCA_init, slot="counts"))
          ) 
```
\normalsize


Then we get around to actually using the model. Here I have the function **nbc.probability.matrix()** which takes an input matrix 
of term or gene frequency and a previously made nbc model. It then produces a matrix for each class with the conditional 
probabilities of each piece of evidence within the term frequency matrix. It has a lengthy computation time and so in the following code
chunk the function and the save have been commented out (this is to ensure that I don't accidentally overwrite the file).

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  
# Using the naive bayes classifier on the Term frequency matricies...
# Running nbc.probability.matrix() takes a long time on large matrices.

# BRC2251 
  nbc.features = nbc.model$features[which(nbc.model$features %in% rownames(tf.1))]
#  npm = nbc.probability.matrix(tf.1[nbc.features,], nbc.model) 
  # save
#    saveRDS(npm, "/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/BRC2251_npm.rds")
    npm = readRDS("/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/BRC2251_npm.rds")
# Predict
  BRC2251.prediction = predict.kde.nbc.from.matrix(tf.1[nbc.features,], npm, nbc.model)
  rm(npm)
  gc() 
   
# BRC2252 
  nbc.features = nbc.model$features[which(nbc.model$features %in% rownames(tf.2))]
#  npm = nbc.probability.matrix(tf.2[nbc.features,], nbc.model) 
  # save
#    saveRDS(npm, "/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/BRC2252_npm.rds")
    npm = readRDS("/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/BRC2252_npm.rds")
# Predict    
  BRC2252.prediction = predict.kde.nbc.from.matrix(tf.2[nbc.features,], npm, nbc.model)
  rm(npm)
  gc() 

# BRC2256
  nbc.features = nbc.model$features[which(nbc.model$features %in% rownames(tf.3))]
#  npm = nbc.probability.matrix(tf.3[nbc.features,], nbc.model) 
  # save
#    saveRDS(npm, "/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/BRC2256_npm.rds")
    npm = readRDS("/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/BRC2256_npm.rds")
# Predict    
  BRC2256.prediction = predict.kde.nbc.from.matrix(tf.3[nbc.features,], npm, nbc.model)
  rm(npm)
  gc() 
   
# BRC2260
  nbc.features = nbc.model$features[which(nbc.model$features %in% rownames(tf.4))]
#  npm = nbc.probability.matrix(tf.4[nbc.features,], nbc.model) 
  # save
#    saveRDS(npm, "/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/BRC2260_npm.rds")
    npm = readRDS("/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/BRC2260_npm.rds")
# Predict    
  BRC2260.prediction = predict.kde.nbc.from.matrix(tf.4[nbc.features,], npm, nbc.model)
  rm(npm)
  gc() 
   
# BRC2262
  nbc.features = nbc.model$features[which(nbc.model$features %in% rownames(tf.5))]
#  npm = nbc.probability.matrix(tf.5[nbc.features,], nbc.model) 
#    saveRDS(npm, "/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/BRC2262_npm.rds")
    npm = readRDS("/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/BRC2262_npm.rds")
# Predict    
  BRC2262.prediction = predict.kde.nbc.from.matrix(tf.5[nbc.features,], npm, nbc.model)
  rm(npm)
  gc() 
   
# BRC2263
  nbc.features = nbc.model$features[which(nbc.model$features %in% rownames(tf.6))]
#  npm = nbc.probability.matrix(tf.6[nbc.features,], nbc.model) 
  # save
#    saveRDS(npm, "/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/BRC2263_npm.rds")
    npm = readRDS("/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/BRC2263_npm.rds")
# Predict    
  BRC2263.prediction = predict.kde.nbc.from.matrix(tf.6[nbc.features,], npm, nbc.model)
  rm(npm)
  gc()  
  
# alexsc
  nbc.features = nbc.model$features[which(nbc.model$features %in% rownames(tf.7))]
#  npm = nbc.probability.matrix(tf.7[nbc.features,], nbc.model) 
  # save
#    saveRDS(npm, "/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/alexsc_npm.rds")
   npm = readRDS("/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/alexsc_npm.rds")
# Predict    
  alexsc.prediction = predict.kde.nbc.from.matrix(tf.7[nbc.features,], npm, nbc.model)
  rm(npm)
  gc() 

# HCA
  nbc.features = nbc.model$features[which(nbc.model$features %in% rownames(tf.8))]
#  npm = nbc.probability.matrix(tf.8[nbc.features,], nbc.model) 
  # save
#    saveRDS(npm, "/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/hca_npm.rds")
   npm = readRDS("/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/heart_cell_classification/hca_npm.rds")
  # We missed a few cells here.. Make a new matrix for those we missed
   npm2 = colnames(HCA_init)[!colnames(HCA_init) %in% colnames(npm[[1]])]
   npm2 = nbc.probability.matrix(tf.8[nbc.features,colnames(HCA_init)[
              !colnames(HCA_init) %in% colnames(npm[[1]])
            ]], nbc.model, 1) 
# Predict, set 1 then set 2
  hca.prediction = predict.kde.nbc.from.matrix(tf.8[nbc.features,colnames(HCA_init)[colnames(HCA_init) %in% colnames(npm[[1]])]], 
    npm, nbc.model
  )
  hca.prediction2 = predict.kde.nbc.from.matrix(tf.8[nbc.features,colnames(HCA_init)[!colnames(HCA_init) %in% colnames(npm[[1]])]], 
    npm2, nbc.model
  )
# Add rows together  
  hca.prediction = rbind(hca.prediction, hca.prediction2)[colnames(HCA_init),]
  rm(npm)
  gc()   

### END - predictions made
```
\normalsize

# Make Seurat objects 
To facilitate further analysis, we will create Seurat objects for each dataset and then stage merged 
and integrated datasets. We omit some code above where we used the random forest
in addition to the naive Bayes classifier to make predictions. The following code includes this 
prediction using the objects ***.rf** and inserting them into the meta data slots of the objects 
after creating them ("$HCC.rf"). Steps for each sample here:

1. Create object
2. SCTransform (normalisation and scaling)
3. PCA using SCTransform residuals
4. UMAP using SCTransform residuals

<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
```{r, eval=T, message=F, echo=F}
  script.name = "make_seurat_objects"
  script.dir = file.path(main.dir, script.name)
  mkdir(script.dir)
  mkdir(script.dir, "figures")
#  BRC2251.so = readRDS(file.path(script.dir, "BRC2251.so.rds"))
#  BRC2252.so = readRDS(file.path(script.dir, "BRC2252.so.rds"))
#  BRC2256.so = readRDS(file.path(script.dir, "BRC2256.so.rds"))
#  BRC2260.so = readRDS(file.path(script.dir, "BRC2260.so.rds"))
#  BRC2262.so = readRDS(file.path(script.dir, "BRC2262.so.rds"))
#  BRC2263.so = readRDS(file.path(script.dir, "BRC2263.so.rds"))
#  alexsc.so = readRDS(file.path(script.dir, "alexsc.so.rds"))
#  hca.so = readRDS(file.path(script.dir, "hca.so.rds"))
#  all.so = readRDS(file.path(script.dir, "all.so.rds"))
#  foetal.all.so = readRDS(file.path(script.dir, "foetal.all.so.rds"))
  

```
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}

### Foetal objects::

#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  
## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## 
# Performance of classifier, cellulalr composition of sample, and visualisation
# Individual classification, how does the model perform?
# What classes can we see in our data?
  # Construct some Seurat Objects and do some dimension reduction...
  
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  # 
# BRC2251
  BRC2251.so <- CreateSeuratObject(BRC2251, assay = "BRC2251")
  BRC2251.so <- SCTransform(BRC2251.so, assay = "BRC2251", new.assay.name = "BRC2251")
  
  BRC2251.so$HCC.rf <- BRC2251.rf
  BRC2251.so$HCC.nbc <- BRC2251.prediction$prediction
  BRC2251.so$QC.fail <- as.factor(as.integer(BRC2251.cells2remove))
  
  BRC2251.so <- RunPCA(BRC2251.so, verbose = FALSE, npcs = 50)
  BRC2251.so <- RunUMAP(BRC2251.so, dims = 1:50, umap.method = "uwot", n.components=2)

  saveRDS(BRC2251.so, file.path(script.dir, "BRC2251.so.rds"))
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  # 
# BRC2252
  BRC2252.so <- CreateSeuratObject(BRC2252, assay = "BRC2252")
  BRC2252.so <- SCTransform(BRC2252.so, assay = "BRC2252", new.assay.name = "BRC2252")
  
  BRC2252.so$HCC.rf <- BRC2252.rf
  BRC2252.so$HCC.nbc <- BRC2252.prediction$prediction
  BRC2252.so$QC.fail <- as.factor(as.integer(BRC2252.cells2remove))
  
  BRC2252.so <- RunPCA(BRC2252.so, verbose = FALSE, npcs = 50)
  BRC2252.so <- RunUMAP(BRC2252.so, dims = 1:50, umap.method = "uwot", n.components=2)
 
  saveRDS(BRC2252.so, file.path(script.dir, "BRC2252.so.rds"))
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  # 
# BRC2256  
  BRC2256.so <- CreateSeuratObject(BRC2256, assay = "BRC2256")
  BRC2256.so <- SCTransform(BRC2256.so, assay = "BRC2256", new.assay.name = "BRC2256")
  
  BRC2256.so$HCC.rf <- BRC2256.rf
  BRC2256.so$HCC.nbc <- BRC2256.prediction$prediction
  BRC2256.so$QC.fail <- as.factor(as.integer(BRC2256.cells2remove))
  
  BRC2256.so <- RunPCA(BRC2256.so, verbose = FALSE, npcs = 50)
  BRC2256.so <- RunUMAP(BRC2256.so, dims = 1:50, umap.method = "uwot", n.components=2)

  saveRDS(BRC2256.so, file.path(script.dir, "BRC2256.so.rds"))
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  # 
# BRC2260  
  BRC2260.so <- CreateSeuratObject(BRC2260, assay = "BRC2260")
  BRC2260.so <- SCTransform(BRC2260.so, assay = "BRC2260", new.assay.name = "BRC2260")
  
  BRC2260.so$HCC.rf <- BRC2260.rf
  BRC2260.so$HCC.nbc <- BRC2260.prediction$prediction
  BRC2260.so$QC.fail <- as.factor(as.integer(BRC2260.cells2remove))
  
  BRC2260.so <- RunPCA(BRC2260.so, verbose = FALSE, npcs = 50)
  BRC2260.so <- RunUMAP(BRC2260.so, dims = 1:50, umap.method = "uwot", n.components=2)
 
  saveRDS(BRC2260.so, file.path(script.dir, "BRC2260.so.rds"))
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  # 
# BRC2262  
   BRC2262.so <- CreateSeuratObject(BRC2262, assay = "BRC2262")
  BRC2262.so <- SCTransform(BRC2262.so, assay = "BRC2262", new.assay.name = "BRC2262")
  
  BRC2262.so$HCC.rf <- BRC2262.rf
  BRC2262.so$HCC.nbc <- BRC2262.prediction$prediction
  BRC2262.so$QC.fail <- as.factor(as.integer(BRC2262.cells2remove))
  
  BRC2262.so <- RunPCA(BRC2262.so, verbose = FALSE, npcs = 50)
  BRC2262.so <- RunUMAP(BRC2262.so, dims = 1:50, umap.method = "uwot", n.components=2)

  saveRDS(BRC2262.so, file.path(script.dir, "BRC2262.so.rds"))
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  # 
# BRC2263  
  BRC2263.so <- CreateSeuratObject(BRC2263, assay = "BRC2263")
  BRC2263.so <- SCTransform(BRC2263.so, assay = "BRC2263", new.assay.name = "BRC2263")
  
  BRC2263.so$HCC.rf <- BRC2263.rf
  BRC2263.so$HCC.nbc <- BRC2263.prediction$prediction
  BRC2263.so$QC.fail <- as.factor(as.integer(BRC2263.cells2remove))
  
  BRC2263.so <- RunPCA(BRC2263.so, verbose = FALSE, npcs = 50)
  BRC2263.so <- RunUMAP(BRC2263.so, dims = 1:50, umap.method = "uwot", n.components=2)
 
  saveRDS(BRC2263.so, file.path(script.dir, "BRC2263.so.rds"))
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  # 
# alexsc 
  alexsc.so <- CreateSeuratObject(alexsc, assay = "alexsc")
  alexsc.so <- SCTransform(alexsc.so, assay = "alexsc", new.assay.name = "alexsc")
  
  alexsc.so$HCC.rf <- alexsc.rf
  alexsc.so$HCC.nbc <- alexsc.prediction$prediction
  alexsc.so$QC.fail <- as.factor(as.integer(alexsc.cells2remove))
  
  alexsc.so <- RunPCA(alexsc.so, verbose = FALSE, npcs = 50)
  alexsc.so <- RunUMAP(alexsc.so, dims = 1:50, umap.method = "uwot", n.components=2)

  saveRDS(alexsc.so, file.path(script.dir, "alexsc.so.rds"))
  
 #  #  #  #  #  #  #  #  #  # 
# ALL FOETAL MERGED
# Combined Foetal
  genes2keep = table(c(rownames(BRC2251)[rowSums(BRC2251) > 10],
                rownames(BRC2252)[rowSums(BRC2252) > 10],
                rownames(BRC2256)[rowSums(BRC2256) > 10],
                rownames(BRC2260)[rowSums(BRC2260) > 10],
                rownames(BRC2262)[rowSums(BRC2262) > 10],
                rownames(BRC2263)[rowSums(BRC2263) > 10],
                rownames(alexsc)[rowSums(alexsc) > 10]             
               ))
  genes2keep = names(genes2keep)[genes2keep > 0]           
  
#  Now we identify the shared gene names between the datasets...
  genes2keep = genes2keep[genes2keep %in% rownames(alexsc) & genes2keep %in% rownames(BRC2251)]
 
  foetal.matrix <- cbind( BRC2251[genes2keep,], 
                    BRC2252[genes2keep,], 
                    BRC2256[genes2keep,],  
                    BRC2260[genes2keep,],  
                    BRC2262[genes2keep,],  
                    BRC2263[genes2keep,], 
                    alexsc[genes2keep,])
  
  colnames(foetal.matrix) = gsub("1$", "", colnames(foetal.matrix))
  colnames(foetal.matrix) = paste(
                                  colnames(foetal.matrix),
                                  rep(
                                      c("BRC2251", 
                                        "BRC2252", 
                                        "BRC2256", 
                                        "BRC2260", 
                                        "BRC2262", 
                                        "BRC2263", 
                                        "alexsc"), 
                                      c(ncol(BRC2251), 
                                        ncol(BRC2252), 
                                        ncol(BRC2256), 
                                        ncol(BRC2260), 
                                        ncol(BRC2262), 
                                        ncol(BRC2263), 
                                        ncol(alexsc))
                                      ),
                                  sep=""
                                  )
# Create Seurat Object 
  foetal.all.so = CreateSeuratObject(foetal.matrix, assay = "RNA")
# Set donor
  foetal.all.so$donor = as.factor(rep(
                             c("BRC2251", 
                               "BRC2252", 
                               "BRC2256", 
                               "BRC2260", 
                               "BRC2262", 
                               "BRC2263", 
                               "alexsc"), 
                             c(ncol(BRC2251), 
                               ncol(BRC2252), 
                               ncol(BRC2256),  
                               ncol(BRC2260), 
                               ncol(BRC2262), 
                               ncol(BRC2263), 
                               ncol(alexsc))
                           ))
# Set QC status
  foetal.all.so$QC.fail = as.factor(c("pass", "fail")[c(BRC2251.so$QC.fail,
                            BRC2252.so$QC.fail,
                            BRC2256.so$QC.fail,
                            BRC2260.so$QC.fail,
                            BRC2262.so$QC.fail,
                            BRC2263.so$QC.fail,
                            alexsc.so$QC.fail)])
# Set randomforest results                                           
  foetal.all.so$HCC.rf = factor(
                        c(as.character(BRC2251.rf[colnames(BRC2251)]),
                        as.character(BRC2252.rf[colnames(BRC2252)]),
                        as.character(BRC2256.rf[colnames(BRC2256)]),
                        as.character(BRC2260.rf[colnames(BRC2260)]),
                        as.character(BRC2262.rf[colnames(BRC2262)]),
                        as.character(BRC2263.rf[colnames(BRC2263)]),
                        as.character(alexsc.rf[colnames(alexsc)])), levels=levels(alexsc.rf)
                        )
# Set NBC results
  foetal.all.so$HCC.nbc = factor(
                          c(as.character(BRC2251.prediction[colnames(BRC2251),"prediction"]),
                            as.character(BRC2252.prediction[colnames(BRC2252),"prediction"]),
                            as.character(BRC2256.prediction[colnames(BRC2256),"prediction"]),
                            as.character(BRC2260.prediction[colnames(BRC2260),"prediction"]),
                            as.character(BRC2262.prediction[colnames(BRC2262),"prediction"]),
                            as.character(BRC2263.prediction[colnames(BRC2263),"prediction"]),
                            as.character(alexsc.prediction[colnames(alexsc),"prediction"])
                          ), 
                        levels=levels(alexsc.prediction$prediction)
                        )
# Set stage
  foetal.all.so$stage = "foetal"                     
                        
                        
                        

# Collect all variable features within samples for the overall sample...                        
  variable.genes.foetal = unique(c(
    VariableFeatures(BRC2251.so),
    VariableFeatures(BRC2252.so),
    VariableFeatures(BRC2256.so),
    VariableFeatures(BRC2260.so),
    VariableFeatures(BRC2262.so),
    VariableFeatures(BRC2263.so),
    VariableFeatures(alexsc.so))
    )
  variable.genes.foetal = variable.genes.foetal[variable.genes.foetal %in% rownames(foetal.all.so)]
  
# We are only doing quick normalisation for this dataset considering we need to 
# QC cut the selectiom
  VariableFeatures(foetal.all.so) = variable.genes.foetal
 
 # Normalise, scale and reduce dimensions 
  foetal.all.so <- NormalizeData(foetal.all.so)
  foetal.all.so <- ScaleData(foetal.all.so)    
  foetal.all.so <- RunPCA(foetal.all.so, verbose = FALSE, npcs = 50)
  foetal.all.so <- RunUMAP(foetal.all.so, dims = 1:50, umap.method = "uwot", n.components=2)
  
# Recode the foetal samples by age order
  foetal.all.so$donor = c("F1", "F2", "F3", "F4", "F5", "F6", "F7")[
    match(foetal.all.so$donor, c("BRC2252", "BRC2262", "BRC2251", "BRC2263", "alexsc", "BRC2256", "BRC2260"))
  ]   
  
# Save the RDS
  saveRDS(foetal.all.so,  file.path(script.dir, "foetal.all.so.rds"))
  
```
\normalsize

# Adult data seurat object
We can repeat the same for the adult dataset, saving for convenience later on.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}

#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  
# Adult 
#  HCA.so$HCC.rf = hca.rf
  HCA.so$HCC.nbc = hca.prediction$prediction
  levels(HCA.so$donor) = c("A1","A2","A3","A4","A5")
  
  HCA.so <- FindVariableFeatures(HCA.so, nfeatures = 8000)
  
  HCA.so <- NormalizeData(HCA.so)
  HCA.so <- ScaleData(HCA.so)    
  HCA.so <- RunPCA(HCA.so, verbose = FALSE, npcs = 50)
  HCA.so <- RunUMAP(HCA.so, dims = 1:50, umap.method = "uwot", n.components=2)
  
  saveRDS(HCA.so, file.path(script.dir, "hca.so.rds"))

```
\normalsize

# Foetal and QC 
## Red blood cell contamination
We observed in the previous analysis of sample F5 (alexsc) that there was a significant contamination
of red blood cells. We removed this using a two compartment Gaussian mixture model and will 
continue to do so here. First, let's have a look at the QC for all samples.

<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
```{r, eval=T, message=F, echo=F}
# NAME
  script.name = "foetal_and_QC"

# DIRECTORY
  script.dir = file.path(main.dir, script.name)
  
# Files
foetal.integrated.RBCs  = readRDS(file.path(script.dir,"foetal.integrated.RBCs.rds"))
   
```
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# Foetal dataset merged temporarily

# Beginning with the foetal dataset, we can check the overall quality control etc 
# and how the data is after QC
# This is a temporary merge
  foetal.all.merged = subset(foetal.all.so, cells=colnames(foetal.all.so)[
                        foetal.all.so$QC.fail == "pass"]
                      )
#    levels(foetal.all.merged$donor) = c("F1", "F2", "F3", "F4", "F5", "F6", "F7")
  foetal.all.merged <- NormalizeData(foetal.all.merged)
  foetal.all.merged <- ScaleData(foetal.all.merged)    

# Quality control plots now for foetal and the adult dataset combined
# Key Data / cells quality stuff
  base.stats <- rbind(foetal.all.merged@meta.data[,c("stage", 
                                                      "donor", 
                                                      "nCount_RNA", 
                                                      "nFeature_RNA", 
                                                      "HCC.nbc")],
                      HCA.so@meta.data[,c("stage", 
                                          "donor", 
                                          "nCount_RNA", 
                                          "nFeature_RNA", 
                                          "HCC.nbc")]
                      )
# Assign plot window parameters
par(mfrow=c(3,2), mar=c(6,6,2,2), oma=c(0,0,0,10))
  boxplot(nCount_RNA ~ donor, base.stats, col = cambridge.sunset[c(9,4,4,4,4,4,4,1,1,1,1,1)], pch=16, cex=0.4, las=3, xlab="")
  mtext("A", 3, adj=-0.2, font=2)
  boxplot(nFeature_RNA ~ donor, base.stats, col = cambridge.sunset[c(9,4,4,4,4,4,4,1,1,1,1,1)], pch=16, cex=0.4, las=3, xlab="")
  mtext("B", 3, adj=-0.2, font=2)
 
# box plots of UMIs and Features
  plot(base.stats$nCount_RNA, base.stats$nFeature_RNA, 
    col=cambridge.sunset[c(9,4,4,4,4,4,4,1,1,1,1,1)][base.stats$donor], 
    pch=16, cex=0.4, xlab="# Reads", ylab="# Features"
  )
  mtext("C", 3, adj=-0.2, font=2)
 
# Quality xy scatter plots
  x = log(sapply(levels(as.factor(base.stats$donor)), function(i) {
    median(base.stats[base.stats$donor == i,"nCount_RNA"])
  }))
  y = log(sapply(levels(as.factor(base.stats$donor)), function(i) {
    median(base.stats[base.stats$donor == i,"nFeature_RNA"])
  }))
  plot(x, y, col=cambridge.sunset[c(9,4,4,4,4,4,4,1,1,1,1,1)], 
    pch=16, ylim=c(6.1,8.3), xlim=c(6.8,10.1), 
    xlab="mean log # Reads", ylab="mean log # Features"
  )
  arrows(x, y, x-sapply(levels(as.factor(base.stats$donor)), function(i) {
    sd(log(base.stats[base.stats$donor == i,"nCount_RNA"]))
  }), y, angle=90, length=0.1, col=cambridge.sunset[c(9,4,4,4,4,4,4,1,1,1,1,1)])
  arrows(x, y, x+sapply(levels(as.factor(base.stats$donor)), function(i) {
    sd(log(base.stats[base.stats$donor == i,"nCount_RNA"]))
  }), y, angle=90, length=0.1, col=cambridge.sunset[c(9,4,4,4,4,4,4,1,1,1,1,1)])
  arrows(x, y, x, y-sapply(levels(as.factor(base.stats$donor)), function(i) {
    sd(log(base.stats[base.stats$donor == i,"nFeature_RNA"]))
  }), angle=90, length=0.1, col=cambridge.sunset[c(9,4,4,4,4,4,4,1,1,1,1,1)])
  arrows(x, y, x, y+sapply(levels(as.factor(base.stats$donor)), function(i) {
    sd(log(base.stats[base.stats$donor == i,"nFeature_RNA"]))
  }), angle=90, length=0.1, col=cambridge.sunset[c(9,4,4,4,4,4,4,1,1,1,1,1)])
  points(x, y, bg=cambridge.sunset[c(9,4,4,4,4,4,4,1,1,1,1,1)], pch=21)
  text.overlay(x,y,levels(as.factor(base.stats$donor)))
  mtext("D", 3, adj=-0.2, font=2)
 
# scatter plot overlayed with the HCC nbc factors  
  plot(base.stats$nCount_RNA, base.stats$nFeature_RNA, col=Discrete12[base.stats$HCC.nbc], 
    pch=16, cex=0.4, xlab="# Reads", ylab="# Features"
  )
  mtext("E", 3, adj=-0.2, font=2)
  
# Bar plots of composition across samples 
  cell.id.matrix <- matrix(0, 12, 12)
    rownames(cell.id.matrix) <- levels(BRC2251.so$HCC.nbc)
    colnames(cell.id.matrix) <- c(
      "F1", "F2", "F3", "F4", "F5", "F6", "F7", "A1", "A2", "A3", "A4", "A5"
    )
    # Foetal
    cell.id.matrix[names(table(BRC2251.so$HCC.nbc)),"F2"] <- table(BRC2251.so$HCC.nbc)
    cell.id.matrix[names(table(BRC2252.so$HCC.nbc)),"F3"] <- table(BRC2252.so$HCC.nbc)
    cell.id.matrix[names(table(BRC2256.so$HCC.nbc)),"F4"] <- table(BRC2256.so$HCC.nbc)
    cell.id.matrix[names(table(BRC2260.so$HCC.nbc)),"F5"] <- table(BRC2260.so$HCC.nbc)
    cell.id.matrix[names(table(BRC2262.so$HCC.nbc)),"F6"] <- table(BRC2262.so$HCC.nbc)
    cell.id.matrix[names(table(BRC2263.so$HCC.nbc)),"F7"] <- table(BRC2263.so$HCC.nbc)
    cell.id.matrix[names(table(alexsc.so$HCC.nbc )),"F1"] <- table(alexsc.so$HCC.nbc )
    # Adult
    cell.id.matrix[names(table(HCA.so$HCC.nbc[HCA.so$donor=="A1"])),"A1"] <- 
      table(HCA.so$HCC.nbc[HCA.so$donor=="A1"])
    cell.id.matrix[names(table(HCA.so$HCC.nbc[HCA.so$donor=="A2"])),"A2"] <- 
      table(HCA.so$HCC.nbc[HCA.so$donor=="A2"])
    cell.id.matrix[names(table(HCA.so$HCC.nbc[HCA.so$donor=="A3"])),"A3"] <- 
      table(HCA.so$HCC.nbc[HCA.so$donor=="A3"])
    cell.id.matrix[names(table(HCA.so$HCC.nbc[HCA.so$donor=="A4"])),"A4"] <- 
      table(HCA.so$HCC.nbc[HCA.so$donor=="A4"])
    cell.id.matrix[names(table(HCA.so$HCC.nbc[HCA.so$donor=="A5"])),"A5"] <- 
      table(HCA.so$HCC.nbc[HCA.so$donor=="A5"])

   barplot(100*t(t(cell.id.matrix)/colSums(cell.id.matrix)), col=Discrete12, las=3, main="%")
   legend.4(legend=levels(BRC2251.so$HCC.nbc), col=Discrete12, pch=16, bty="n")   
   mtext("F", 3, adj=-0.2, font=2)

```
\normalsize


\scriptsize
```{r, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{QC_Supp} Data quality characteristics and Heart Cell Classifier results showing the spread of A, UMIs; B, Features; C + D, UMIs vs Features (mean +- SD); and E - F, Heart Cell Types", echo=FALSE}
  knitr::include_graphics("output/v_2/foetal_and_QC/figures/QC_all_supplementary_figure.pdf")
```
\normalsize

It appears as though there are a large number of erythrocytes in the foetal samples.
The next step shows how we identify these and remove them. Firstly, we take all foetal 
samples and try to gain some experiment-level information by integrating the foetal datasets.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}

# Integrate the foetal datasets by their donor
  foetal.list <- SplitObject(foetal.all.merged, split.by = "donor")
 
  for (i in 1:length(foetal.list)) {
    foetal.list[[i]] <- NormalizeData(foetal.list[[i]], verbose = FALSE)
    foetal.list[[i]] = FindVariableFeatures(foetal.list[[i]])
  }
  gc()
  
  foetal.anchors <- FindIntegrationAnchors(object.list = foetal.list, dims = 1:30, anchor.features=2000)
  foetal.integrated.RBCs <- IntegrateData(anchorset = foetal.anchors, dims = 1:30)
    
  foetal.integrated.RBCs <- ScaleData(foetal.integrated.RBCs, verbose = FALSE)
  foetal.integrated.RBCs <- RunPCA(foetal.integrated.RBCs, verbose = FALSE, npcs = 50)
  foetal.integrated.RBCs <- RunUMAP(foetal.integrated.RBCs, dims = 1:50, umap.method = "uwot", n.components=2) 
  foetal.integrated.RBCs$HCC.nbc <- factor(foetal.integrated.RBCs$HCC.nbc, levels=levels(foetal.all.merged$HCC.nbc))
  foetal.integrated.RBCs$HCC.rf <- factor(foetal.integrated.RBCs$HCC.rf, levels=levels(foetal.all.merged$HCC.rf))
  foetal.integrated.RBCs$donor = factor(foetal.integrated.RBCs$donor)
  levels(foetal.integrated.RBCs$donor) = c("F1", "F2", "F3", "F4", "F5", "F6", "F7")

```
\normalsize

Then we are able to identify the red blood cells using the expression of key red blood cell genes. 
Here I pull up the haemoglobulin genes and run a gaussian mixture model (GMM) on the mean expression of 
these genes in each cell.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# RBC cleaning...
# Pull up RBC associated genes
  rbc.sig <- c("HBB", "HBG1", "HBG2", "HBM",  "HBA2", "HBA1", "HBQ1", "ALAS2")
  rbc.sig = rbc.sig[rbc.sig %in% rownames(foetal.list[[1]])]
# Loop across each sample - sample effects may influence the GMM classification  
  for (i in 1:length(foetal.list)) {
  # isolate the RBC gene expressions
    counts.m = as.matrix(log2(GetAssayData(foetal.list[[i]], slot="counts")[rbc.sig,]+1))
  # zero centre
    counts.m = (counts.m-rowMeans(counts.m))/rowSds(counts.m)
  # take the column means for "RBC score"
    foetal.list[[i]]$rbc.score = colMeans(counts.m)
  # two-partitions, GMM, apply for each foetal sample
    foetal.list[[i]]$rbc.class  = Mclust(foetal.list[[i]]$rbc.score, G=2)$classification
  # Identify which group is RCB ++ (by max expression call)
    rbc.group = which.max(sapply(1:2, function(k) {
      mean(counts.m[,foetal.list[[i]]$rbc.class==k])
    }))
  # Label groups
    foetal.list[[i]]$rbc.class[foetal.list[[i]]$rbc.class == rbc.group] = "RBC"
    foetal.list[[i]]$rbc.class[foetal.list[[i]]$rbc.class != "RBC"] = ""
  }
  gc()  
# Generate class and score vectors, generate new metadata annotation in integrated object
  rbc.class=unlist(sapply(1:length(foetal.list), function(i){foetal.list[[i]]$rbc.class}))
  rbc.score=unlist(sapply(1:length(foetal.list), function(i){foetal.list[[i]]$rbc.score}))
  foetal.integrated.RBCs$rbc.class = rbc.class[colnames(foetal.integrated.RBCs)]
  foetal.integrated.RBCs$rbc.score = rbc.score[colnames(foetal.integrated.RBCs)]

# Save for loading later      
  saveRDS(foetal.integrated.RBCs, file.path("output/v_2/foetal_and_QC", "foetal.integrated.RBCs.rds"))
 
```
\normalsize
\scriptsize
```{r, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{RBC_pre} UMAP projections of the foetal samples integrated which shows A, the integration of donors; B, the classification of cells from the heart cell classifier; C, the classification from a gaussian mixture model identifying red blood cells; and D, the expression of red blood cell genes. ", echo=FALSE}
  knitr::include_graphics("figures/foetal_fig1.pdf")
```
\normalsize
To observe the foetal integration, heart cell classification as well as red blood cell 
contamination and identification at this stage we can plot the UMAP with various annotations.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# Figure showing the Red Blood Cell contamination (umaps)
    par(mfrow=c(2,2), oma=c(0,0,0,8), mar=c(4,4,2,9), cex=0.5)
    plot.so(foetal.integrated.RBCs, "donor", Discrete, leg=T, cex=1)
    plot.so(foetal.integrated.RBCs, "HCC.nbc", Discrete12, leg=T, cex=1)
    plot.so(foetal.integrated.RBCs, "rbc.class", Discrete, leg=T, cex=1)
    plot(Embeddings(foetal.integrated.RBCs, reduction="umap")[,1:2], 
      col=plotcols(colMeans(GetAssayData(foetal.integrated.RBCs)[c("HBA2", "HBA1", "HBB"),,drop=F])), cex=0.5, pch=16, ylab="")
    gradient.legend(colMeans(GetAssayData(foetal.integrated.RBCs)[c("HBA2", "HBA1", "HBB"),,drop=F]), colours=alt.cols, scale=0.9)

```
\normalsize

The last step before we have our matrices ready for further analysis, 
we aim to call good cells by using the combined information across
samples to inform us of red blood cells. We combine a clustering across all samples with the 
individual GMM results to give us a robust identifier of red blood cells in our experiment.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# Clustering
  foetal.integrated.RBCs <- FindNeighbors(foetal.integrated.RBCs, k.param=500)
  foetal.integrated.RBCs <- FindClusters(foetal.integrated.RBCs, resolution=1)
  foetal.integrated.RBCs$clusters = Idents(foetal.integrated.RBCs)
 
# Bring up clusters to annotate as RBC clusters 
  clusters = Idents(foetal.integrated.RBCs)
# For each cluster, generate aggregate RBC scores  
  clusters.HCC = sapply(levels(clusters) , function(i) {
    table(foetal.integrated.RBCs$HCC.nbc[clusters==i])
  })
  RBC.HCC.score = round(100*clusters.HCC["RBCs",] / colSums(clusters.HCC), 2)
   
# Label good clusters by < 50 % RBC contamination
# Good cells are only if they are non-RBC according to the GMM AND belong to 
# non-RBC clusters (< 50 % RBCs).
# Conversely, bad cells are identified as RBC using the GMM and 
# their lack of annotation as a good cluster after data integration.
# This ensures that we use experiment-level information (multiple samples) 
# to inform of RBC contaminant cluster to remove all cells that are RBC in RBC clusters, 
# but retain cells that are non-RBC in non-RBC clusters. 
  good.clusters = levels(clusters)[as.numeric(which(RBC.HCC.score < 50))]
  good.cells = names(Idents(foetal.integrated.RBCs))[Idents(foetal.integrated.RBCs) %in% good.clusters & foetal.integrated.RBCs$rbc.class %in% ""]

# add metadata to integrated object  
  foetal.integrated.RBCs$good.cells = "bad"
  foetal.integrated.RBCs$good.cells[good.cells] = "good"

# Save the RBCs object for later
  saveRDS(foetal.integrated.RBCs, file.path("output/v_2/foetal_and_QC", "foetal.integrated.RBCs.rds"))
 
# plot the cells with these annotations
  plot.so(foetal.integrated.RBCs, "good.cells", Discrete.U, leg=T)
  plot.so(foetal.integrated.RBCs, "clusters", Discrete.U, leg=T)  
   
```
\normalsize

\scriptsize
```{r, eval=T, message=F, echo=F, fig.width=5.6, fig.height=9,  fig.align='center', out.width="0.6\\linewidth", fig.cap="\\label{FigRBCresults} Two UMAP plots showing the integrated foetal dataset with annotated clusters and ultimate identification of good or bad cells."}
   par(mfrow=c(2,1), oma=c(0,0,0,8))
#   foetal.integrated.RBCs = readRDS(file.path("output/v_2/foetal_and_QC", "foetal.integrated.RBCs.rds"))
# Bring up clusters to annotate as RBC clusters 
  clusters = Idents(foetal.integrated.RBCs)
# For each cluster, generate aggregate RBC scores  
  clusters.HCC = sapply(levels(clusters) , function(i) {
    table(foetal.integrated.RBCs$HCC.nbc[clusters==i])
  })
  RBC.HCC.score = round(100*clusters.HCC["RBCs",] / colSums(clusters.HCC), 2)
  good.clusters = levels(clusters)[as.numeric(which(RBC.HCC.score < 50))]
  good.cells = names(Idents(foetal.integrated.RBCs))[Idents(foetal.integrated.RBCs) %in% good.clusters & foetal.integrated.RBCs$rbc.class %in% ""]

# add metadata to integrated object  
  foetal.integrated.RBCs$good.cells = "bad"
  foetal.integrated.RBCs$good.cells[good.cells] = "good"

  plot.so(foetal.integrated.RBCs, "good.cells", Discrete.U, leg=T)
  plot.so(foetal.integrated.RBCs, "clusters", Discrete.U, leg=T)   
  rm(foetal.integrated.RBCs); gc()
```
\normalsize

We can observe what happens to our dataset after removing these red blood cells. We see that the majority of red blood cell classified cells 
are removed after this decontamination step.

\scriptsize
```{r, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{RBC_post} UMAP projection of the foetal dataset after removing red blood cells showing the distribution of A; donors, B; RBC genes; C, cell types; and D, bar charts showing cell type composition.", echo=FALSE}
 knitr::include_graphics("figures/foetal_fig2.pdf")
```
\normalsize



 
\scriptsize
```{r, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{Foetal_integrated_pre_subclusters} UMAP projections of the foetal samples integrated which shows A, the integration of donors; B, the classification of cells from the heart cell classifier; C, the classification from a gaussian mixture model identifying red blood cells; and D, the expression of red blood cell genes. ", echo=FALSE}
  knitr::include_graphics("figures/foetal_fig3.pdf")
```
\normalsize


# All.so - the large merged dataset
We can generate a single overall object (without any processing) ready for further analysis. In 
this object I include the metadata "doublet" as an indicator of predicted doublet through a separate 
program **Solo**. This object will form the basis of the future analyses and we ensure that the 
metadata and annotations are properly up to date.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# Constructing the overall matrix of adult and foetal... (before we get into the stage-specific stuff)  
# EDIT colnames... of the previous datasets...  
  colnames(alexsc ) = gsub("-1", "-alexsc",  colnames(alexsc) )
  colnames(BRC2251) = gsub("-1", "-BRC2251", colnames(BRC2251))
  colnames(BRC2252) = gsub("-1", "-BRC2252", colnames(BRC2252))
  colnames(BRC2256) = gsub("-1", "-BRC2256", colnames(BRC2256))
  colnames(BRC2260) = gsub("-1", "-BRC2260", colnames(BRC2260))
  colnames(BRC2262) = gsub("-1", "-BRC2262", colnames(BRC2262))
  colnames(BRC2263) = gsub("-1", "-BRC2263", colnames(BRC2263))
  
# Good cells = RBC and QC cut for foetal... HCA.so has already been cleaned
# First we merge based on rowname similarities, take the intersect of all genes.
  shared.feature.names = intersect(
                           rownames(alexsc), 
                             intersect(
                                rownames(BRC2251), 
                                rownames(HCA.so)
                           )
                         )
# And merge matrices by adding sets as new columns together by their shared rownames
# subset by the "good cells".                         
  all.so <- cbind(
    alexsc[shared.feature.names,  colnames(alexsc) %in% good.cells ],
    BRC2251[shared.feature.names, colnames(BRC2251) %in% good.cells],
    BRC2252[shared.feature.names, colnames(BRC2252) %in% good.cells],
    BRC2256[shared.feature.names, colnames(BRC2256) %in% good.cells],
    BRC2260[shared.feature.names, colnames(BRC2260) %in% good.cells],
    BRC2262[shared.feature.names, colnames(BRC2262) %in% good.cells],
    BRC2263[shared.feature.names, colnames(BRC2263) %in% good.cells],
    GetAssayData(HCA.so, slot="counts")[shared.feature.names,]
  )
 

# Now we cut the genes from the matrix.
# We remove genes from matrix if they are expressed in < 5 cells in all samples.
# This is essential as there may be gene expression present in one sample but absent 
# in another. Careful, this is the realm of lazy but functional coding.
  all.genes = c(
    rownames(foetal.all.merged.cut)[rowSums(
      GetAssayData(foetal.all.merged.cut, slot="counts", assay="RNA")[
        ,names(foetal.all.merged.cut$donor)[foetal.all.merged.cut$donor=="F1"]]
      ) > 4],
    rownames(foetal.all.merged.cut)[rowSums(
      GetAssayData(foetal.all.merged.cut, slot="counts", assay="RNA")[
        ,names(foetal.all.merged.cut$donor)[foetal.all.merged.cut$donor=="F2"]]
      ) > 4],
    rownames(foetal.all.merged.cut)[rowSums(
      GetAssayData(foetal.all.merged.cut, slot="counts", assay="RNA")[
        ,names(foetal.all.merged.cut$donor)[foetal.all.merged.cut$donor=="F3"]]
      ) > 4],
    rownames(foetal.all.merged.cut)[rowSums(
      GetAssayData(foetal.all.merged.cut, slot="counts", assay="RNA")[
        ,names(foetal.all.merged.cut$donor)[foetal.all.merged.cut$donor=="F4"]]
      ) > 4],
    rownames(foetal.all.merged.cut)[rowSums(
      GetAssayData(foetal.all.merged.cut, slot="counts", assay="RNA")[
        ,names(foetal.all.merged.cut$donor)[foetal.all.merged.cut$donor=="F5"]]
      ) > 4],
    rownames(foetal.all.merged.cut)[rowSums(
      GetAssayData(foetal.all.merged.cut, slot="counts", assay="RNA")[
        ,names(foetal.all.merged.cut$donor)[foetal.all.merged.cut$donor=="F6"]]
      ) > 4],
    rownames(foetal.all.merged.cut)[rowSums(
      GetAssayData(foetal.all.merged.cut, slot="counts", assay="RNA")[
        ,names(foetal.all.merged.cut$donor)[foetal.all.merged.cut$donor=="F7"]]
      ) > 4],
    rownames(HCA.so)[rowSums(
        GetAssayData(HCA.so, slot="counts", assay="RNA")[,names(HCA.so$donor)[HCA.so$donor=="A1"]]
      ) > 4],
    rownames(HCA.so)[rowSums(
        GetAssayData(HCA.so, slot="counts", assay="RNA")[,names(HCA.so$donor)[HCA.so$donor=="A2"]]
      ) > 4],
    rownames(HCA.so)[rowSums(
        GetAssayData(HCA.so, slot="counts", assay="RNA")[,names(HCA.so$donor)[HCA.so$donor=="A3"]]
      ) > 4],
    rownames(HCA.so)[rowSums(
        GetAssayData(HCA.so, slot="counts", assay="RNA")[,names(HCA.so$donor)[HCA.so$donor=="A4"]]
      ) > 4],
    rownames(HCA.so)[rowSums(
        GetAssayData(HCA.so, slot="counts", assay="RNA")[,names(HCA.so$donor)[HCA.so$donor=="A5"]]
      ) > 4]
  )
# Pull all these together, finding unique only.
  genes4analysis = unique(all.genes)
  genes4analysis = genes4analysis[genes4analysis %in% rownames(all.so)]
  
# subset rows for the overall matrix now by those genes which are expressed
  all.so = all.so[genes4analysis,] 
  gc()
  
# And finally we create a Seurat Object of all good cells and their important variables.
  all.so = CreateSeuratObject(all.so, assay="RNA")
  
# Edit and add the covariates / conditions and meta data annotations
# Stage
  all.so$stage  = "foetal"
  all.so$stage[grep("HCA", colnames(all.so))]  = "adult"
# Set donor
  all.so$donor = as.factor(
                    c(as.character(foetal.all.merged.cut$donor[
                        colnames(all.so)[all.so$stage=="foetal"]
                      ]),
                      as.character(HCA.so$donor[colnames(all.so)[all.so$stage=="adult"]])
                    )
                  ) 
# Set randomforest results                                           
  all.so$HCC.rf = factor(
                    c(as.character(foetal.all.merged.cut$HCC.rf[
                        colnames(all.so)[all.so$stage=="foetal"]
                      ]),
                      as.character(HCA.so$HCC.rf[colnames(all.so)[all.so$stage=="adult"]])
                    ), 
                    levels=levels(BRC2251.so)
                  )
# Set NBC results
   all.so$HCC.nbc = factor(
                      c(as.character(foetal.all.merged.cut$HCC.nbc[
                          colnames(all.so)[all.so$stage=="foetal"]
                        ]),
                        as.character(HCA.so$HCC.nbc[colnames(all.so)[all.so$stage=="adult"]])
                      ), 
                      levels=levels(BRC2251.so)
                    )

# Set cell type as according to the HCA definitions                        
    all.so$cell.type = "foetal"; 
    all.so$cell.type[grep("HCA",colnames(all.so))] = as.character(
      HCA.so$cell.type[colnames(all.so)[grep("HCA",colnames(all.so))]]
    )
    all.so$cell.type = factor(all.so$cell.type)
    all.so$cell.type = factor(
      all.so$cell.type, levels=levels(all.so$cell.type)[c(1,4,8,9,6,2,10,5,3,7,11)]
    )
# Doublet scores (at least for the Foetal)
    all.so$doublet = factor(rep(0,ncol(all.so)), levels=c(0,1))
# Read in from Solo working directory   
  BRC2251.doublets = read.csv('/mnt/LocalHDD/raw_data/G_Fetal_hearts/solo/BRC2251/solo_out/BRC2251_doublets.csv', head=F)
     rownames(BRC2251.doublets) = gsub("-1", "-BRC2251", colnames(BRC2251.cut))
  BRC2252.doublets = read.csv('/mnt/LocalHDD/raw_data/G_Fetal_hearts/solo/BRC2252/solo_out/BRC2252_doublets.csv', head=F)
     rownames(BRC2252.doublets) = gsub("-1", "-BRC2252", colnames(BRC2252.cut))
  BRC2256.doublets = read.csv('/mnt/LocalHDD/raw_data/G_Fetal_hearts/solo/BRC2256/solo_out/BRC2256_doublets.csv', head=F)
     rownames(BRC2256.doublets) = gsub("-1", "-BRC2256", colnames(BRC2256.cut))
  BRC2260.doublets = read.csv('/mnt/LocalHDD/raw_data/G_Fetal_hearts/solo/BRC2260/solo_out/BRC2260_doublets.csv', head=F)
     rownames(BRC2260.doublets) = gsub("-1", "-BRC2260", colnames(BRC2260.cut))
  BRC2262.doublets = read.csv('/mnt/LocalHDD/raw_data/G_Fetal_hearts/solo/BRC2262/solo_out/BRC2262_doublets.csv', head=F)
     rownames(BRC2262.doublets) = gsub("-1", "-BRC2262", colnames(BRC2262.cut))
   BRC2263.doublets = read.csv('/mnt/LocalHDD/raw_data/G_Fetal_hearts/solo/BRC2263/solo_out/BRC2263_doublets.csv', head=F)
     rownames(BRC2263.doublets) = gsub("-1", "-BRC2263", colnames(BRC2263.cut))
   
# Assign to object
  all.so$doublet[colnames(all.so)[all.so$donor == "F2"]] = 
    BRC2251.doublets[colnames(all.so)[all.so$donor == "F2"],]
  all.so$doublet[colnames(all.so)[all.so$donor == "F3"]] = 
    BRC2252.doublets[colnames(all.so)[all.so$donor == "F3"],]
  all.so$doublet[colnames(all.so)[all.so$donor == "F4"]] = 
    BRC2256.doublets[colnames(all.so)[all.so$donor == "F4"],]
  all.so$doublet[colnames(all.so)[all.so$donor == "F5"]] = 
    BRC2260.doublets[colnames(all.so)[all.so$donor == "F5"],]
  all.so$doublet[colnames(all.so)[all.so$donor == "F6"]] = 
    BRC2262.doublets[colnames(all.so)[all.so$donor == "F6"],]
  all.so$doublet[colnames(all.so)[all.so$donor == "F7"]] = 
    BRC2263.doublets[colnames(all.so)[all.so$donor == "F7"],]
  
# relabel the Foetal samples by date order...  These old names were outside of date order.  
  all.so$donor = c("F1", "F2", "F3", "F4", "F5", "F6", "F7", "A1", "A2", "A3", "A4", "A5")[
    match(all.so$donor, c("F3", "F6", "F2", "F7", "F1", "F4", "F5", "A1", "A2", "A3", "A4", "A5"))]
 
# We're going to save this because the next few steps might crash R...
  saveRDS(all.so, file.path(script.dir, "all.so.rds"))
  
# Additionally, we calculate the variable genes for the further analyses  
# calculate the variable genes for feeding into the analysis:  
  all.list <- SplitObject(all.so, split.by = "donor")
  
  options(future.globals.maxSize = 4000 * 1024^2)
  for (i in 1:length(all.list)) {
     all.list[[i]] <- NormalizeData(all.list[[i]], verbose = FALSE)
     all.list[[i]] <- FindVariableFeatures(all.list[[i]], selection.method = "vst")
    gc()    
  }
  
 # USING simple and quick calculations...  
   variable.genes = unique(c(
                            VariableFeatures(all.list[[1]] ), 
                            VariableFeatures(all.list[[2]] ), 
                            VariableFeatures(all.list[[3]] ), 
                            VariableFeatures(all.list[[4]] ), 
                            VariableFeatures(all.list[[5]] ),
                            VariableFeatures(all.list[[6]] ),
                            VariableFeatures(all.list[[7]] ),
                            VariableFeatures(all.list[[8]] ),
                            VariableFeatures(all.list[[9]] ),
                            VariableFeatures(all.list[[10]]),
                            VariableFeatures(all.list[[11]]),
                            VariableFeatures(all.list[[12]])
                            ))
  saveRDS(variable.genes, file.path(script.dir, "variable.genes.rds"))     
```
\normalsize


## Classification results
This section is included here for ease, simply because we can run it in a new window after formatting our datasets. It uses 
the HCC labels defined in each Seurat object and calculates statistics based on some new clustering and processing.

<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
```{r, eval=T, message=F, echo=F}



######################################################
# Script details

# NAME
  script.name = "results_classifier"

# DESCRIPTION
  # What is the classifier performance?

# DIRECTORY
  script.dir = file.path(main.dir, script.name)

  mkdir(script.dir)
  mkdir(script.dir, "figures")
######################################################



```
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}

# FOETAL 
# All together merged in one dataset...  
# Merging of foetal cells
  foetal.list <- subset(all.so, cells = colnames(all.so)[grep("F", all.so$donor)], slot="counts")
  
# Split to list and process
  foetal.list <- SplitObject(foetal.list, split.by = "donor")

# Normalise samples individually  
   for (i in 1:length(foetal.list)) {
    foetal.list[[i]] <- NormalizeData(foetal.list[[i]], verbose = FALSE)
  }
  gc()
  
# merge split list  and apply variable features
  foetal.merged = merge(
    foetal.list[[1]], 
    list(
      foetal.list[[2]], 
      foetal.list[[3]], 
      foetal.list[[4]], 
      foetal.list[[5]], 
      foetal.list[[6]], 
      foetal.list[[7]]
    )
  )
  VariableFeatures(foetal.merged) = variable.genes

# Scale, PCA, UMAP  
  foetal.merged <- ScaleData(foetal.merged, verbose = FALSE)
  foetal.merged <- RunPCA(foetal.merged, verbose = FALSE, npcs = 50)
  foetal.merged <- RunUMAP(foetal.merged, dims = 1:50, umap.method = "uwot", n.components=2) 

# Re-level factors in object  
  foetal.merged$HCC.nbc <- factor(foetal.merged$HCC.nbc, levels=levels(all.so$HCC.nbc))
  foetal.merged$HCC.rf <- factor(foetal.merged$HCC.rf, levels=levels(all.so$HCC.rf))
  foetal.merged$doublet = all.so$doublet[colnames(foetal.merged)]
 
# cluster
  foetal.merged = FindNeighbors(foetal.merged, k = 30)
  foetal.merged = FindClusters(foetal.merged, res = 1)

# plot clusters
  DimPlot(foetal.merged, label=T, cols=Discrete.U)

# Here we can identify which cell type is the major component of each cluster, using this information to label all cells within that cluster as 
# the most dominant cell type
  for(k in levels(Idents(foetal.merged))){
    nbc.tab = table(foetal.merged$HCC.nbc[Idents(foetal.merged) == k])
    foetal.merged.labels[Idents(foetal.merged) == k] = names(nbc.tab)[which.max(nbc.tab)]
  }
  
# We create new labels and use old factor levels  
  foetal.merged.labels = factor(foetal.merged.labels, levels = levels(foetal.merged$HCC.nbc))

# And finally construct a confusion matrix between the HCC predictions and cluster-based labels 
  foetal.merged.cm = confusionMatrix(foetal.merged$HCC.nbc, foetal.merged.labels)
   
```
\normalsize
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
```{r, eval=T, message=F, echo=F}
  DimPlot(foetal.merged, label=T, cols=Discrete.U)
```
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->

Repeat for the adult cells, filtered from the object we made with all cells and samples (**all.so**). However, to determine the classifier 
accuracy etc we should really re-label the adult cells to that we are consistent with the cell types ready for the classifier statistics.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}

# adult
  adult.list <- subset(all.so, cells = colnames(all.so)[grep("A", all.so$donor)], slot="counts")
  
# Split to list and process
  adult.list <- SplitObject(adult.list, split.by = "donor")
  
  for (i in 1:length(adult.list)) {
    adult.list[[i]] <- NormalizeData(adult.list[[i]], verbose = FALSE)
  }
  gc()
  
  adult.merged = merge(adult.list[[1]], list(adult.list[[2]], adult.list[[3]], adult.list[[4]], adult.list[[5]]))
  VariableFeatures(adult.merged) = variable.genes
  
  adult.merged <- ScaleData(adult.merged, verbose = FALSE)
  adult.merged <- RunPCA(adult.merged, verbose = FALSE, npcs = 50)
  adult.merged <- RunUMAP(adult.merged, dims = 1:50, umap.method = "uwot", n.components=2) 
  adult.merged$HCC.nbc <- factor(adult.merged$HCC.nbc, levels=levels(all.so$HCC.nbc))
    levels(adult.merged$HCC.nbc)[5] = "Immune cells"  
  adult.merged$HCC.rf <- factor(adult.merged$HCC.rf, levels=levels(all.so$HCC.rf))
  
  adult.merged = FindNeighbors(adult.merged, k = 30)
  adult.merged = FindClusters(adult.merged, res = 1)

# Quick plot of Seurat clusters  
  DimPlot(adult.merged, label=T)

### Re-label the adult labels by their most major cell type  
  adult.merged.labels = as.character(Idents(adult.merged))
  names(adult.merged.labels) = names(Idents(adult.merged))
  
# label predicted vs cluster
  for(k in levels(Idents(adult.merged))){
    nbc.tab = table(adult.merged$HCC.nbc[Idents(adult.merged) == k])
    adult.merged.labels[Idents(adult.merged) == k] = names(nbc.tab)[which.max(nbc.tab)]
  }
  
# Need to edit the HCA definitions to standardise the labelling...
# Re-label the cll_states classes
  cell_states = HCA_init$cell.states[colnames(adult.merged)]
  adult.merged$cell.states = cell_states
  adult.merged$alt.labels = as.character(adult.merged$cell.type) 
  adult.merged$alt.labels[cell_states[colnames(adult.merged)] == "EC7_atria"] = "Endocardial"
  adult.merged$alt.labels[cell_states[colnames(adult.merged)] == "Meso"] = "Epicardial"
  adult.merged$alt.labels[cell_states[colnames(adult.merged)] == "nan"] = "Ventricular CMs"
  adult.merged$alt.labels[adult.merged$alt.labels %in% c("Lymphoid","Myeloid")] = "Immune cells"
  adult.merged$alt.labels[adult.merged$alt.labels %in% c("Neuronal")] = "unknown"
  adult.merged$alt.labels[adult.merged$alt.labels %in% c("Fibroblast")] = "Cardiac Fibroblast"
  adult.merged$alt.labels[adult.merged$alt.labels %in% c("Pericytes")] = "SMCs / Pericytes"
  adult.merged$alt.labels[adult.merged$alt.labels %in% c("Smooth_muscle_cells")] = "SMCs / Pericytes"
  adult.merged$alt.labels[adult.merged$alt.labels %in% c("doublets")] = "unknown"
  adult.merged$alt.labels = factor(adult.merged$alt.labels, levels=levels(adult.merged$HCC.nbc))

# confusion matrix
  adult.merged.cm = confusionMatrix(adult.merged$HCC.nbc, adult.merged$alt.labels)
```
\normalsize

We create individual confusion matrices for each sample (because there are instance where a class has 0 entries and causes NA issues).
Then we can create overall stats tables for our results.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
   
########
# Subset the merged data to extract sample-specific statistics  
# Foetal
  F1.cm = confusionMatrix(foetal.merged$HCC.nbc[grep("BRC2252", colnames(foetal.merged))], 
    foetal.merged.labels[grep("BRC2252", colnames(foetal.merged))]
  )
  F2.cm = confusionMatrix(foetal.merged$HCC.nbc[grep("BRC2262", colnames(foetal.merged))], 
    foetal.merged.labels[grep("BRC2262", colnames(foetal.merged))]
  )
  F3.cm = confusionMatrix(foetal.merged$HCC.nbc[grep("BRC2251", colnames(foetal.merged))], 
    foetal.merged.labels[grep("BRC2251", colnames(foetal.merged))]
  )
  F4.cm = confusionMatrix(foetal.merged$HCC.nbc[grep("BRC2263", colnames(foetal.merged))], 
    foetal.merged.labels[grep("BRC2263", colnames(foetal.merged))]
  )
  F5.cm = confusionMatrix(foetal.merged$HCC.nbc[grep("alexsc",  colnames(foetal.merged))], 
    foetal.merged.labels[grep("alexsc",  colnames(foetal.merged))]
  )
  F6.cm = confusionMatrix(foetal.merged$HCC.nbc[grep("BRC2256", colnames(foetal.merged))], 
    foetal.merged.labels[grep("BRC2256", colnames(foetal.merged))]
  )
  F7.cm = confusionMatrix(foetal.merged$HCC.nbc[grep("BRC2260", colnames(foetal.merged))], 
    foetal.merged.labels[grep("BRC2260", colnames(foetal.merged))]
  )
    
# Adult   
  A1.cm = confusionMatrix(adult.merged$HCC.nbc[adult.merged$donor == "A1"], adult.merged$alt.labels[adult.merged$donor == "A1"])
  A2.cm = confusionMatrix(adult.merged$HCC.nbc[adult.merged$donor == "A2"], adult.merged$alt.labels[adult.merged$donor == "A2"])
  A3.cm = confusionMatrix(adult.merged$HCC.nbc[adult.merged$donor == "A3"], adult.merged$alt.labels[adult.merged$donor == "A3"])
  A4.cm = confusionMatrix(adult.merged$HCC.nbc[adult.merged$donor == "A4"], adult.merged$alt.labels[adult.merged$donor == "A4"])
  A5.cm = confusionMatrix(adult.merged$HCC.nbc[adult.merged$donor == "A5"], adult.merged$alt.labels[adult.merged$donor == "A5"])


## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## 
# Stats table::
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   
# Accuracies:::
  acc.df = sapply(levels(as.factor(all.so$donor)), function(i) {
    get(paste(i, ".cm", sep=""))$byClass[,"Balanced Accuracy"]
  })
  acc.df = as.data.frame(acc.df)
  acc.df$cell_type = levels(adult.merged$HCC.nbc)
  write.table(acc.df, file=file.path(script.dir, "accuracy_table.csv"), sep=",", quote=F, col.names=T, row.names=F)
  
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  
# Recalls:::
  recall.df = sapply(levels(as.factor(all.so$donor)), function(i) {
    get(paste(i, ".cm", sep=""))$byClass[,"Recall"]
  })
  recall.df = as.data.frame(recall.df)
  recall.df$cell_type = levels(adult.merged$HCC.nbc)
  write.table(recall.df, file=file.path(script.dir, "recall_table.csv"), sep=",", quote=F, col.names=T, row.names=F)
  
           
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  
# Precisions:::
  precision.df = sapply(levels(as.factor(all.so$donor)), function(i) {
    get(paste(i, ".cm", sep=""))$byClass[,"Precision"]
  })
  precision.df = as.data.frame(precision.df)
  precision.df$cell_type = levels(adult.merged$HCC.nbc)
  write.table(precision.df, file=file.path(script.dir, "precision_table.csv"), sep=",", quote=F, col.names=T, row.names=F)
  
# results file (R) 
    CM.list.results = list(
    "F1" = F1.cm,
    "F2" = F2.cm,
    "F3" = F3.cm,
    "F4" = F4.cm,
    "F5" = F5.cm,
    "F6" = F6.cm,
    "F7" = F7.cm,
    "A1" = A1.cm,
    "A2" = A2.cm,
    "A3" = A3.cm,
    "A4" = A4.cm,
    "A5" = A5.cm,
    "foetal.merged" = foetal.merged.cm,
    "adult.merged" = adult.merged.cm
  )
 saveRDS(CM.list.results, file.path(script.dir, "confusion_matrices.rds"))  
  
```
\normalsize

Now we can visualise the overall confusion matrix, here we take the combined matrix and plot it out including mean statistics for columns 
and rows (recall and precision). 

\scriptsize
```{r, eval=T, fig.width=11.3, fig.height=7,  fig.align='center', out.width="0.5\\linewidth", fig.cap="\\label{fig13} Confusion matrix for foetal classification between clusters and HCC."}
# Read in our confusion matrices
  CM.list.results = readRDS(file.path(script.dir, "confusion_matrices.rds"))  

# Parse to objects 
  for(i in names(CM.list.results)){
    assign(paste(i,".cm", sep=""), CM.list.results[[i]])
  }
# Begin figure 
par(mfrow=c(1,2), oma=c(2,5,5,3))
# foetal CM matrix to plot
  matrix2plot = t(  
    t(
      as.matrix(foetal.merged.cm$table)  )  /  (colSums(as.matrix(foetal.merged.cm$table))+1
    )
  )
# Run function (custom matrix plot function (see library))
  matrix.plot(matrix2plot, Heat, ylab="", xlab="")

# Calculate per-class mean recall and precision (ignoring NAs)  
  mean.recall = sapply(1:12, function(i){mean(recall.df[i,6:12][!is.na(recall.df[i,6:12])])})
  mean.precision = sapply(1:12, function(i){mean(precision.df[i,6:12][!is.na(precision.df[i,6:12])])})
   
# Plot the mean recall and precision under column and rows respectively
  points(1:12, rep(-1, 12), col=colorRampPalette(alt.cols)(101)[round(100*mean.recall)+1], pch=15, cex=3, xpd=NA)
    axis(2, at=-1, label="Recall", xpd=NA, las=2)
  points(rep(14, 12), 1:12, col=colorRampPalette(alt.cols)(101)[round(100*mean.precision)+1], pch=15, cex=3, xpd=NA)
    axis(3, at=14, label="Precision", xpd=NA, las=2)

# label sides
  mtext("Predicted", 2, padj=-10)
  mtext("Reference", 3, padj=-10)

# add legend
  gradient.legend(seq(0,1,0.1), colours=alt.cols, distance=2, scale=0.8, cex=0.7)

## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## 
# adult CM matrix to plot
  matrix2plot = t(  
    t(
      as.matrix(adult.merged.cm$table)  )  /  (colSums(as.matrix(adult.merged.cm$table))+1
    )
  )
# Run function (custom matrix plot function (see library))
  matrix.plot(matrix2plot, Heat, ylab="", xlab="", y.axis=F)

# Calculate per-class mean recall and precision (ignoring NAs)  
  mean.recall = sapply(1:12, function(i){mean(recall.df[i,1:5][!is.na(recall.df[i,1:5])])})
  mean.precision = sapply(1:12, function(i){mean(precision.df[i,1:5][!is.na(precision.df[i,1:5])])})
   
# Plot the mean recall and precision under column and rows respectively
  points(1:12, rep(-1, 12), col=colorRampPalette(alt.cols)(101)[round(100*mean.recall)+1], pch=15, cex=3, xpd=NA)
    axis(2, at=-1, label="Recall", xpd=NA, las=2)
  points(rep(14, 12), 12:1, col=colorRampPalette(alt.cols)(101)[round(100*mean.precision)+1], pch=15, cex=3, xpd=NA)
    axis(3, at=14, label="Precision", xpd=NA, las=2)

# label sides
  mtext("Reference", 3, padj=-10)

# add legend
  gradient.legend(seq(0,1,0.1), colours=alt.cols, distance=2, scale=0.8, cex=0.7)

```
\normalsize

And here we also create the figure 1c in the manuscrupt using the following large section of code.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# Recalculate tables - we  remove NAs and the cell_type column
  acc.df = sapply(levels(as.factor(all.so$donor)), function(i) {
      get(paste(i, ".cm", sep=""))$byClass[,"Balanced Accuracy"]
    })
   
  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  
  # Recalls:::
    recall.df = sapply(levels(as.factor(all.so$donor)), function(i) {
      get(paste(i, ".cm", sep=""))$byClass[,"Recall"]
    })
   
             
  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  
  # Precisions:::
    precision.df = sapply(levels(as.factor(all.so$donor)), function(i) {
      get(paste(i, ".cm", sep=""))$byClass[,"Precision"]
    })
   
# na corrections 
  recall.df[is.na(recall.df)] = 0
  acc.df[is.na(acc.df)] = 0
  precision.df[is.na(precision.df)] = 0
     
  
     
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   
# Figure accuracy:
  acc.df[is.na(acc.df)] = 0
 
  par(col.lab="black", col.axis="black", mfrow=c(1,3), mar=c(4,1,1,2), oma=c(0,2,0,0))
    plot(c(1,12), range(acc.df), pch=NA, xlab="sample", ylab="Balanced Accuracy", ylim=c(0, 1), xaxt="n", main="Accuracy")
    
    abline(h=c(0.5, 0.6, 0.7,0.8,0.9,1), lty=3, col="grey")
    abline(v=1:12, lty=2, col="grey")
    abline(v=5.5, lty=1, col="black")
      axis(1, at=c(1:12), tcl=-0.3, label=NA)
      
      axis(1, at=c(1,5), label=c("", ""), line=1.2, tcl=0.5)
        axis(1, at=3, label="Adult 1-5", line=1.2, tcl=-0.5)
      axis(1, at=c(6,12), label=c("", ""), line=1.2, tcl=0.5)
        axis(1, at=9, label="Foetal 1-7", line=1.2, tcl=-0.5)
        
    for(i in 1:length(acc.df[1,])){
      lines(c(5.5,16), rep(foetal.merged.cm$byClass[i,"Balanced Accuracy"],2), col=Discrete12[i], lwd=2, lend=3)
    }
      par(col.axis=Discrete12[8]); axis(4, at=foetal.merged.cm$byClass[8,"Balanced Accuracy"], 
              label=signif(foetal.merged.cm$byClass[8,"Balanced Accuracy"],3), col=Discrete12[8], lwd=2
              )
    for(i in 1:length(acc.df[1,])){
      lines(c(-5,5.5), rep(adult.merged.cm$byClass[i,"Balanced Accuracy"],2), col=Discrete12[i], lwd=2, lend=3)
    }
     par(col.axis=Discrete12[8]); axis(2, at=adult.merged.cm$byClass[8,"Balanced Accuracy"], 
              label=signif(adult.merged.cm$byClass[8,"Balanced Accuracy"],3), col=Discrete12[8], lwd=2
              )
     for(i in 1:length(acc.df[1,])){
      points(rep(i,length(acc.df[,1])), acc.df[,i], bg=Discrete12, pch=21)
     }      
          box()
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  
# Recalls:::
## FIGURE recalls
  recall.df[is.na(recall.df)] = 0
 
  par(col.lab="black", col.axis="black")
    plot(c(1,12), range(recall.df), pch=NA, xlab="sample", ylab="Recall", ylim=c(0, 1), xaxt="n", main="Recall", yaxt="n")
    
    abline(h=c(0.5, 0.6, 0.7,0.8,0.9,1), lty=3, col="grey")
    abline(v=1:12, lty=2, col="grey")
    abline(v=5.5, lty=1, col="black")
      axis(1, at=c(1:12), tcl=-0.3, label=NA)
      
      axis(1, at=c(1,5), label=c("", ""), line=1.2, tcl=0.5)
        axis(1, at=3, label="Adult 1-5", line=1.2, tcl=-0.5)
      axis(1, at=c(6,12), label=c("", ""), line=1.2, tcl=0.5)
        axis(1, at=9, label="Foetal 1-7", line=1.2, tcl=-0.5)
        
    for(i in 1:length(recall.df[1,])){
      lines(c(5.5,16), rep(foetal.merged.cm$byClass[i,"Recall"],2), col=Discrete12[i], lwd=2, lend=3)
    }
      par(col.axis=Discrete12[8]); axis(4, at=foetal.merged.cm$byClass[8,"Recall"], 
              label=signif(foetal.merged.cm$byClass[8,"Recall"],3), col=Discrete12[8], lwd=2
              )
    for(i in 1:length(recall.df[1,])){
      lines(c(-5,5.5), rep(adult.merged.cm$byClass[i,"Recall"],2), col=Discrete12[i], lwd=2, lend=3)
    }
     par(col.axis=Discrete12[8]); axis(2, at=adult.merged.cm$byClass[8,"Recall"], 
              label=signif(adult.merged.cm$byClass[8,"Recall"],3), col=Discrete12[8], lwd=2
              )
    for(i in 1:length(recall.df[1,])){
      points(rep(i,length(recall.df[,1])), recall.df[,i], bg=Discrete12, pch=21)
    }               
        box()       
              
#  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  
# Precisions:::
 ## FIGURE Precisions
  precision.df[is.na(precision.df)] = 0
 
  par(col.lab="black", col.axis="black")
    plot(c(1,12), range(precision.df), pch=NA, xlab="sample", ylab="Precision", ylim=c(0, 1), xaxt="n", main="Precision", yaxt="n")
    
    abline(h=c(0.5, 0.6, 0.7,0.8,0.9,1), lty=3, col="grey")
    abline(v=1:12, lty=2, col="grey")
    abline(v=5.5, lty=1, col="black")
      axis(1, at=c(1:12), tcl=-0.3, label=NA)
      
      axis(1, at=c(1,5), label=c("", ""), line=1.2, tcl=0.5)
        axis(1, at=3, label="Adult 1-5", line=1.2, tcl=-0.5)
      axis(1, at=c(6,12), label=c("", ""), line=1.2, tcl=0.5)
        axis(1, at=9, label="Foetal 1-7", line=1.2, tcl=-0.5)
        
    for(i in 1:length(precision.df[1,])){
      lines(c(5.5,16), rep(foetal.merged.cm$byClass[i,"Precision"],2), col=Discrete12[i], lwd=2, lend=3)
    }
      par(col.axis=Discrete12[8]); axis(4, at=foetal.merged.cm$byClass[8,"Precision"], 
              label=signif(foetal.merged.cm$byClass[8,"Precision"],3), col=Discrete12[8], lwd=2
              )
    for(i in 1:length(precision.df[1,])){
      lines(c(-5,5.5), rep(adult.merged.cm$byClass[i,"Precision"],2), col=Discrete12[i], lwd=2, lend=3)
    }
     par(col.axis=Discrete12[8]); axis(2, at=adult.merged.cm$byClass[8,"Precision"], 
              label=signif(adult.merged.cm$byClass[8,"Precision"],3), col=Discrete12[8], lwd=2
              )
    for(i in 1:length(precision.df[1,])){
      points(rep(i,length(precision.df[,1])), precision.df[,i], bg=Discrete12, pch=21)
    } 
    box()  

```
\normalsize


```{r, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{fig14} Figure 1C from manuscript showing the Accuracy, Recall and Precision of the classifier over all classes and across adult and foetal datasets.", echo=FALSE}
  knitr::include_graphics(file.path(script.dir, "figures", "ARP.pdf"))
```



## Summary of the first section
This report is a detailed account of the working script behind the analysis of project GHI. We have read in both datasets, removing 
noisy cells and useless genes from the counts matrices. We made cell type predictions for the remaining cells, compiling this infomation into
new individual Seurat objects. Additionally, we have made efforts to remove blood cells and QC failed cells and doublets from several larger objects, 
including the Seurat object **all.so**. We will build a lot of the further elements of the analysis using this object. Then we showd that the 
classifier worked well for predicting epicardial cells, highly specific but with losses of recall moving into adult data. 
Finally, a few points to consider. We felt that it was more obvious from a reading perspective to re-label the foetal samples 
by their developmental age - the adult samples were labelled in their donor order which does not reflect their age, however our assumption was 
that the adult samples may still be more homogenous despite the range in age being more than 10 years. Some of the functions in this 
script are part of my custom functions library which will is available on the shared Sinha Laboratory google server. On a final note, 
this is only part 1 of this series split due to practical limitations of PDF sizes. See you on the other side.


# Part 2:
We will now begin to properly pull samples together using Seurat's integration workflow. We will begin with the foetal samples.

## Foetal integration

The first step is to load in the foetal data, we have these stored in the large **all.so** object and we'll pull the relevant cells out.
At the same time, you can see that I re-label some of the heart cell classification annotations based on posterior knowledge and 
expert contribution from other researchers after the classifier was built.

<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
```{r, eval=T, message=F, echo=F}
######################################################
# Script details

# NAME
  script.name = "foetal_and_results"

# DESCRIPTION
  # script focusing more on the cleaning of data ready for 
  # performing our analyses..
  # gene filtering
  # cell filtering
  # batch correction
  # unknown contamination correction

# DIRECTORY
  script.dir = file.path(main.dir, script.name)

  mkdir(script.dir)
  mkdir(script.dir, "figures")
######################################################
# data2load
  if(!exists("all.so")){
    all.so = readRDS("output/v_2/make_seurat_objects/all.so.rds")
    all.so <- subset(all.so, cells=colnames(all.so)[all.so$doublet==0])
    levels(all.so$HCC.nbc) = levels(all.so$HCC.nbc)
    levels(all.so$HCC.nbc)[1] = "unknown"
    levels(all.so$HCC.nbc)[2] = "Atrial-like CMs"
    levels(all.so$HCC.nbc)[9] = "Fibroblast-like"
    levels(all.so$HCC.nbc)[5] = "Immune cells"
    levels(all.so$HCC.rf)[1] = "unknown"
    levels(all.so$HCC.rf)[2] = "Atrial-like CMs"
    levels(all.so$HCC.rf)[9] = "Fibroblast-like"
    levels(all.so$HCC.rf)[5] = "Immune cells"
  }
  
 foetal.cluster.markers = readRDS("/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/foetal.integrated.markers_feb2021.rds")
 epicardial.integrated = readRDS("/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/epicardial.integrated_feb2021.rds")
   
if(!exists("foetal.integrated")){  
  foetal.integrated = readRDS("/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/foetal.integrated_feb2021.rds")
  levels(foetal.integrated$HCC.nbc) = levels(all.so$HCC.nbc)
  levels(foetal.integrated$HCC.nbc)[1] = "unknown"
  levels(foetal.integrated$HCC.nbc)[2] = "Atrial-like CMs"
  levels(foetal.integrated$HCC.nbc)[9] = "Fibroblast-like"
  levels(foetal.integrated$HCC.nbc)[5] = "Immune cells"
  levels(foetal.integrated$HCC.rf)[1] = "unknown"
  levels(foetal.integrated$HCC.rf)[2] = "Atrial-like CMs"
  levels(foetal.integrated$HCC.rf)[9] = "Fibroblast-like"
  levels(foetal.integrated$HCC.rf)[5] = "Immune cells"
}  
 
```
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->



\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}

# Load all.so
  all.so <<- readRDS("output/v_2/make_seurat_objects/all.so.rds")
  all.so <- subset(all.so, cells=colnames(all.so)[all.so$doublet==0])
  levels(all.so$HCC.nbc) = levels(all.so$HCC.nbc)
  levels(all.so$HCC.nbc)[1] = "unknown"
  levels(all.so$HCC.nbc)[2] = "Atrial-like CMs"
  levels(all.so$HCC.nbc)[9] = "Fibroblast-like"
  levels(all.so$HCC.nbc)[5] = "Immune cells"
  levels(all.so$HCC.rf)[1] = "unknown"
  levels(all.so$HCC.rf)[2] = "Atrial-like CMs"
  levels(all.so$HCC.rf)[9] = "Fibroblast-like"
  levels(all.so$HCC.rf)[5] = "Immune cells"

# variable.genes
  variable.genes = readRDS("output/v_2/make_seurat_objects/variable.genes.rds")

# Load foetal.all.so for RBCs comparison...
  foetal.all.so <<- readRDS(file.path("output", paste("v_",analysis.version,sep=""), "make_seurat_objects/foetal.all.so.rds"))
  levels(foetal.all.so$HCC.nbc) = levels(all.so$HCC.nbc)
  levels(foetal.all.so$HCC.nbc)[1] = "unknown"
  levels(foetal.all.so$HCC.nbc)[2] = "Atrial-like CMs"
  levels(foetal.all.so$HCC.nbc)[9] = "Fibroblast-like"
  levels(foetal.all.so$HCC.nbc)[5] = "Immune cells"
  levels(foetal.all.so$HCC.rf)[1] = "unknown"
  levels(foetal.all.so$HCC.rf)[2] = "Atrial-like CMs"
  levels(foetal.all.so$HCC.rf)[9] = "Fibroblast-like"
  levels(foetal.all.so$HCC.rf)[5] = "Immune cells"
```
\normalsize


Integrating the data using Seurat requires us to create a list of Seruat objects, here we split the datasets by **donor** into a 
list of foetal objects and normalise within each sample.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# Subset to make foetal only set
  foetal.list <- subset(all.so, cells = colnames(all.so)[grep("F", all.so$donor)])
  
# Split to list and process
  foetal.list <- SplitObject(foetal.list, split.by = "donor")
  
# Normalise
  for (i in 1:length(foetal.list)) {
    foetal.list[[i]] <- NormalizeData(foetal.list[[i]], verbose = FALSE)
    VariableFeatures(foetal.list[[i]]) <- variable.genes
  }
  gc()
  
# Then we create anchors, here I used the variable features to include in the downstream analysis
  foetal.anchors <- FindIntegrationAnchors(object.list = foetal.list, dims = 1:30, anchor.features=variable.genes)
# and integrate the data  
  foetal.integrated <- IntegrateData(anchorset = foetal.anchors, dims = 1:30, features=variable.genes)

```
\normalsize

After integration we can scale and run dimension reduction, resulting in the integrated dataset on the manuscript. We should format the 
factors and meta data to ensure that it's consistent between initial and integrated datasets.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# Scale
 foetal.integrated <- ScaleData(foetal.integrated, verbose = FALSE)
# PCA 
  foetal.integrated <- RunPCA(foetal.integrated, verbose = FALSE, npcs = 70); 
   pca.eig = (foetal.integrated[["pca"]]@stdev^2)/sum(foetal.integrated[["pca"]]@stdev^2)*100
   plot(pca.eig)
# UMAP
  foetal.integrated <- RunUMAP(foetal.integrated, dims = 1:30, umap.method = "uwot", n.components=2, min.dist = 0.3, spread = 1, n.neighbors=50)

# Metadata annotations
  foetal.integrated$HCC.nbc <- factor(foetal.integrated$HCC.nbc, levels=levels(all.so$HCC.nbc))
  foetal.integrated$HCC.rf <- factor(foetal.integrated$HCC.rf, levels=levels(all.so$HCC.rf))
  foetal.integrated$donor = c("F1", "F2", "F3", "F4", "F5", "F6", "F7", "A1", "A2", "A3", "A4", "A5")[match(foetal.integrated$donor, c("F3", "F6", "F2", "F7", "F1", "F4", "F5", "A1", "A2", "A3", "A4", "A5"))]
 
```
\normalsize

<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
```{r, eval=T, message=F, echo=F}
  pca.eig = (foetal.integrated[["pca"]]@stdev^2)/sum(foetal.integrated[["pca"]]@stdev^2)*100
  plot(pca.eig)

```
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->
<!-- SILENT SILENT SILENT SILENT SILENT SILENT SILENT -->

And cluster the results using the leiden clustering algorithm. I follow this by using the Heart Cell Classifier (HCC) results to label the 
composition of each leiden cluster.


\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}

# Clustering
  foetal.integrated <- FindNeighbors(foetal.integrated, k.param=100, dims=1:10)
  foetal.integrated <- FindClusters(foetal.integrated, resolution=1)
  foetal.integrated$clusters = Idents(foetal.integrated)

# HCC composition
  clusters.foetal.integrated = sapply(levels(foetal.integrated$seurat_clusters) , function(i) {table(foetal.integrated$HCC.nbc[foetal.integrated$seurat_clusters==i])}) 
  clusters.foetal.100 = 100*t(t(clusters.foetal.integrated)/ colSums(clusters.foetal.integrated))
  clusters.foetal.100       
```
\normalsize

\scriptsize
```{r, eval=T, message=F, echo=F, tidy=F}
  clusters.foetal.integrated = sapply(levels(foetal.integrated$seurat_clusters) , function(i) {table(foetal.integrated$HCC.nbc[foetal.integrated$seurat_clusters==i])}) 
  clusters.foetal.100 = 100*t(t(clusters.foetal.integrated)/ colSums(clusters.foetal.integrated))
  clusters.foetal.100
     
```
\normalsize


\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# Shuffle cells
  RO = shuffle(1:dim(foetal.integrated)[2])
  
# open plot window, plot donor, HCC, clusters and cell type composition plots
  par(mfrow=c(2,2), oma=c(1,2,0,8), mar=c(4,4,2,9), cex=0.5)
  plot.so(foetal.integrated, "donor", Discrete, leg=T, cex=0.6, main="", RO=RO)
  plot.so(foetal.integrated, "HCC.nbc", Discrete12, leg=F, cex=0.6, main="", RO=RO)
  plot.so(foetal.integrated, "clusters", Discrete.U, leg=T, cex=0.6, main="", RO=RO)
  barplot(100*t(t(clusters.foetal.100)/colSums(clusters.foetal.100))[,(c(17,15,11,2,13,9,4,14,16,10,5,12,8,6,7,3,1))], 
   col=Discrete12, las=3, main="%"
  )
  legend.4(legend=levels(foetal.integrated$HCC.nbc), col=Discrete12, pch=16, bty="n") 


```
\normalsize


```{r, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{fig15} Foetal integrated UMAPs leaving us an overlap of donors, coordination of HCC predictions and cell types covered by 17 clusters.", echo=FALSE}
  knitr::include_graphics("figures/foetal_fig3.pdf")
```

This leaves us with 17 clusters. However we notice that there is a separation between two epicardial annotated clusters (see the barplot 
above and the UMAP with HCC annotations). We seek to parse the fibroblast / SMC / RBC / EPI conglomerate further to separate this 
out into individual clusters.

## Epicardial / Fibroblast sub-clustering
We noticed the clusters 0,2,5,11,14 and 15 were associated with this conglomerate. We chose to include SMCs to also try to distinguish 
between SMC or pericyte clusters in foetal hearts but this was not effective. This following code was effective at parsing out the 
epicardial cells from the fibroblast cluster while also aggregating similar composition clusters.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# Split up the Epi and fibroblast groups from the rest...
  epicardial.integrated = subset(foetal.integrated, cells=colnames(foetal.integrated)[Idents(foetal.integrated) %in% c(2,0,11,14,15,5)])
  
# Rescale and run PCA / UMAPs  
  epicardial.integrated <- ScaleData(epicardial.integrated, verbose = FALSE)
  epicardial.integrated <- RunPCA(epicardial.integrated, verbose = FALSE, npcs = 50)
  epicardial.integrated <- RunUMAP(epicardial.integrated, dims = 1:30, umap.method = "uwot", 
                                    n.components=2, min.dist=0.3, spread=1, n.neighbors=50
                                  )

# Update factor labelling and metadata annotations
  epicardial.integrated$HCC.nbc <- factor(epicardial.integrated$HCC.nbc, levels=levels(all.so$HCC.nbc))
  epicardial.integrated$HCC.rf <- factor(epicardial.integrated$HCC.rf, levels=levels(all.so$HCC.rf))
  epicardial.integrated$f.cluster <- factor(Idents(foetal.integrated)[colnames(epicardial.integrated)])

# Cluster new data subset - dims used are 1:24 PCA dims with eigenvalue above 1 % variance
  epicardial.integrated <- FindNeighbors(epicardial.integrated, k.param=100, dims=1:24)
  epicardial.integrated <- FindClusters(epicardial.integrated, resolution=1)
  epicardial.integrated$clusters  =  Idents(epicardial.integrated)
 
# Plot clusters alongside HCC results  
  par(mfrow=c(2,1), oma=c(0,0,0,20)) 
  plot.so(epicardial.integrated, "clusters", Discrete.U, leg=T)   
  plot.so(epicardial.integrated, "HCC.nbc", Discrete12, leg=T)
```
\normalsize

```{r, out.width="1\\linewidth", include=TRUE, fig.align="center", fig.cap="\\label{fig16} Sub clustering of the epicardium, fibroblasts and SMC clusters etc. Resulting in 8 new clusters after aggregating correlating clusters here.", echo=FALSE}
  knitr::include_graphics("figures/fibroblast_subclusters.pdf")
```

Finally, we can then combine our clustering results to come up with the foetal clusters for our integrated dataset. These are the cluster used for 
the stratified sampling stage.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
## Foetal clusters combined, let's make up some cluster names:
  cluster.codes = unique(sapply(1:100, function(i){paste(sample(LETTERS,6), collapse="")}))

# encode subclusters with new unique ID
  epicardial.integrated.clusters = epicardial.integrated$clusters
  levels(epicardial.integrated.clusters) = rev(cluster.codes)[1:length(unique(epicardial.integrated$clusters))]
# encode clusters with new unique ID
  foetal.integrated.clusters = foetal.integrated$clusters
  levels(foetal.integrated.clusters) = cluster.codes[1:length(unique(foetal.integrated$clusters))]

# take cell names from foetal clusters   
  fcnames = names(foetal.integrated.clusters)
  # extract cluster scrambled IDs
    foetal.clusters = as.character(foetal.integrated.clusters)
  # update with cell names   
    names(foetal.clusters) = fcnames
  # Where every cell is in the new subset, we take that cell and replace its cluster ID with the scrambled subset ID
    foetal.clusters[names(epicardial.integrated.clusters)] = as.character(epicardial.integrated.clusters)

# Make into new factors and add to foetal integrated object
  foetal.clusters = as.factor(foetal.clusters)
  foetal.integrated$foetal.clusters = foetal.clusters  

# We take the mean expression of genes within each new cluster (to aggregate similar clusters) and run correlations
  cluster.mean.expressions = sapply(levels(foetal.integrated$foetal.clusters), function(k) {
        rowMeans(GetAssayData(foetal.integrated[,colnames(foetal.integrated)[(foetal.integrated$foetal.clusters == k)]]))
      })
  mcor = cor(cluster.mean.expressions)
  heatmap(mcor, col=colorRampPalette(c("white", "black"))(256), las=2)

# We also take the mean expression matrix and for each cluster pair, we run correlations and merge if they 
# pass a threshold of 0.99 correlation
  clusters.aggregate = aggregate.clusters(foetal.integrated$foetal.clusters, cluster.mean.expressions, 0.99)
  # Calculate relative composition of each cell type in each cluster
  clusters.agg = sapply(levels(clusters.aggregate) , function(i) {table(foetal.integrated$HCC.nbc[clusters.aggregate==i])})
    # Update name with fraction of major cell type
      levels(clusters.aggregate) =   sapply(levels(clusters.aggregate), function(i){
        paste(i, " - ", names(which.max(clusters.agg[,i])), " (", round(100*max(clusters.agg[,i])/sum(clusters.agg[,i]),2), "%)", sep="")
      })

# We update the object with this new cluster, including Idents
  foetal.integrated$clusters.aggregate = clusters.aggregate
  Idents(foetal.integrated) = foetal.integrated$clusters.aggregate
     
# Lastly, we can recalculate the mean gene expressions, new correlation matrix and order our clusters.
 cluster.mean.expressions2 = sapply(levels(Idents(foetal.integrated)), function(k) {
        rowMeans(GetAssayData(foetal.integrated[,colnames(foetal.integrated)[(Idents(foetal.integrated) == k)]]))
      })
      mcor2 = cor(cluster.mean.expressions2)
      oops = heatmap(mcor2, col=colorRampPalette(c("white", "black"))(256), las=2)
   # relevelling lines, using the denrogram order from the heatmap "oops":
  foetal.integrated$clusters.relevelled = factor(as.character(Idents(foetal.integrated)), levels=levels(Idents(foetal.integrated))[oops$colInd])
  Idents(foetal.integrated) = foetal.integrated$clusters.relevelled
  levels(Idents(foetal.integrated)) = gsub("^.*- ", "", levels(Idents(foetal.integrated)))

```
\normalsize

Before we more onto the adult dataset, I quickly run a clustering analysis using Seurat's Wilcoxon rank-sum tests. And we also save all of our
results for pulling later on into the analsis (without running all of these things again)


\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}
# Find markers
  foetal.cluster.markers <- FindAllMarkers(foetal.integrated)
  # relabel the clusters, making them more simple
    foetal.cluster.markers$cluster = gsub("^.*- ", "", foetal.cluster.markers$cluster)
    
# Save our important files..
  saveRDS(foetal.cluster.markers, "/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/foetal.integrated.markers_feb2021.rds")
  saveRDS(foetal.integrated, "/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/foetal.integrated_feb2021.rds")
  saveRDS(epicardial.integrated, "/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/epicardial.integrated_feb2021.rds")
     
```
\normalsize

We can generate a heatmap of the top cluster markers just to examine what exactly these clusters express on average in contrast to the 
other clusters. Please excuse the code, it's largely butchered from quickly working through this data analysis.

\scriptsize
```{r, eval=T, fig.width=15, fig.height=15,  fig.align='center', out.width="1\\linewidth", fig.cap="\\label{fig17} Top 5 cluster markers in foetal integrated data across 21 clusters."}
   
# Retrieve top n genes
  n = 200
  
# Cut by alpha
  alpha = 1e-10
  l2fc.cut = 0.5
  foetal.cluster.markers.cut <- foetal.cluster.markers[foetal.cluster.markers$p_val_adj < alpha,]

# Run function for both up and down l2fc genes...
# exceptionally messy to understand, a lot of subsetting here
  top.gene = lapply(levels(Idents(foetal.integrated)), function(k) {
    rbind(
      head(foetal.cluster.markers.cut[foetal.cluster.markers.cut$cluster==k,][
          foetal.cluster.markers.cut[foetal.cluster.markers.cut$cluster==k,"avg_logFC"] > l2fc.cut,
        ],n),
        head(foetal.cluster.markers.cut[foetal.cluster.markers.cut$cluster==k,][
          foetal.cluster.markers.cut[foetal.cluster.markers.cut$cluster==k,"avg_logFC"] < -l2fc.cut,
        ],n)
    )
  }); names(top.gene) = levels(Idents(foetal.integrated))
  
  top.gene.foetal = top.gene
  
  featureset <- na.omit(unique(as.vector(unlist(sapply(1:length(top.gene),function(i){top.gene[[i]]$gene[1:5]})))))
 
    DoHeatmap(foetal.integrated, features=featureset, group.colors=Discrete.U)   
```
\normalsize


And also we can see the final output as is seen in the manuscript, figure 1E (foetal integrated dataset)

\scriptsize
```{r, eval=T, fig.width=7, fig.height=5,  fig.align='center', out.width="1\\linewidth", fig.cap="\\label{fig18} Final HCC output of the foetal integration ready for sampling (as seen in Figure 1E)."}
   par(oma=c(0,0,0,7))
     plot.so(foetal.integrated, "HCC.nbc", Discrete12, leg=F, cex=0.6, main="")
     legend.4(legend=levels(all.so$HCC.nbc), col=Discrete12, pch=16, bty="n") 

```
\normalsize


## Adult integration
We now need to pull the adult donors together. To do so, I simply run the same commands as above and cluster them. However, we will end up using 
the previous annotations from the Heart Cell Atlas (**cell_states** metadata) to sample. This appeared to be a reasonable granularity of 
cell types spread across the dataset. Here we go... Firstly, we'll subset the **all.so** object by adult cells only, then split the object and 
normalise each donor before merging and integrating.



\scriptsize
```{r, eval=T, message=F, echo=F, tidy=F}


######################################################
# Script details

# NAME
  script.name = "adult_and_results"

# DESCRIPTION
  # script focusing more on the cleaning of data ready for 
  # performing our analyses..
  # gene filtering
  # cell filtering
  # batch correction
  # unknown contamination correction

# DIRECTORY
  script.dir = file.path(main.dir, script.name)

  mkdir(script.dir)
  mkdir(script.dir, "figures")
######################################################

# Adult obs object
 HCA.obs <- read.csv("HCA2020/hca2020_obs.csv", head=T, row.names=1)
  colnames(HCA.obs) <- gsub("_", "\\.", colnames(HCA.obs))

# Adult integrated object
if(!exists("adult.integrated")){  
  adult.integrated = readRDS("/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/adult.integrated_feb2021.rds")
  levels(adult.integrated$HCC.nbc) = levels(all.so$HCC.nbc)
  levels(adult.integrated$HCC.nbc)[1] = "unknown"
  levels(adult.integrated$HCC.nbc)[2] = "Atrial-like CMs"
  levels(adult.integrated$HCC.nbc)[9] = "Fibroblast-like"
  levels(adult.integrated$HCC.nbc)[5] = "Immune cells"
  levels(adult.integrated$HCC.rf)[1] = "unknown"
  levels(adult.integrated$HCC.rf)[2] = "Atrial-like CMs"
  levels(adult.integrated$HCC.rf)[9] = "Fibroblast-like"
  levels(adult.integrated$HCC.rf)[5] = "Immune cells"
}
```
\normalsize


\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}

# Subset to make adult only set
  adult.list <- subset(all.so, cells = colnames(all.so)[grep("A", all.so$donor)])
  
# Split to list and process
  adult.list <- SplitObject(adult.list, split.by = "donor")

# Normalize and run variable features  
  for (i in 1:length(adult.list)) {
    adult.list[[i]] <- NormalizeData(adult.list[[i]], verbose = FALSE)
    VariableFeatures(adult.list[[i]]) <- variable.genes
  }
  gc()
  
# Use our variable.genes object as anchors (to maintain uniformity of analysis), integrate objects
  adult.anchors <- FindIntegrationAnchors(object.list = adult.list, dims = 1:30, anchor.features=variable.genes)    
  adult.integrated <- IntegrateData(anchorset = adult.anchors, dims = 1:30, features=variable.genes)

# update the metadata annotations  
  adult.integrated$HCC.nbc <- factor(adult.integrated$HCC.nbc, levels=levels(all.so$HCC.nbc))
  adult.integrated$HCC.rf <- factor(adult.integrated$HCC.rf, levels=levels(all.so$HCC.rf))
  adult.integrated$cell.states = factor(HCA.obs[colnames(adult.integrated),"cell_states"])
  adult.integrated$donor = c("F1", "F2", "F3", "F4", "F5", "F6", "F7", "A1", "A2", "A3", "A4", "A5")[match(adult.integrated$donor, c("F3", "F6", "F2", "F7", "F1", "F4", "F5", "A1", "A2", "A3", "A4", "A5"))]

# Scale data and run PCA  
  adult.integrated <- ScaleData(adult.integrated, verbose = FALSE)
  adult.integrated <- RunPCA(adult.integrated, verbose = FALSE, npcs = 70)
  adult.integrated <- RunUMAP(adult.integrated, dims = 1:30, umap.method = "uwot", n.components=2, min.dist = 0.3, spread = 2, n.neighbors=50)

# Look at eigen values  
  pca.eig = (adult.integrated[["pca"]]@stdev^2)/sum(adult.integrated[["pca"]]@stdev^2)*100

```
\normalsize

\scriptsize
```{r, eval=T, fig.width=7, fig.height=5,  fig.align='center', out.width="1\\linewidth", fig.cap="\\label{fig19} Eigenvalues for adul integrated PCA."}
plot(pca.eig); abline(h=1, lty=2); which(pca.eig > 1)

```
\normalsize

After integration, dimension reduction and formatting the dataset we can cluster the cells and aggregate clusters together using the same 
workflow as in the foetal dataset. However, we continue with using the **cell_state** annotation as previously discussed instead of these new 
aggregated clusters.

\scriptsize
```{r, eval=F, message=T, echo=T, tidy=F}

# Clustering using Serat's default and top dims from PCA > 1 %
  adult.integrated <- FindNeighbors(adult.integrated, k.param=50, dims=1:18)
  adult.integrated <- FindClusters(adult.integrated, resolution=1)

# update Idents()  
  adult.integrated$clusters = Idents(adult.integrated)

# Aggregate clusters and relabel according to the previous cell_type annotations
  clusters.adult.integrated = sapply(levels(Idents(adult.integrated)) , function(i) {table(adult.integrated$HCC.nbc[Idents(adult.integrated)==i])}) 
      clusters.aggregate = aggregate.clusters(Idents(adult.integrated), clusters.adult.integrated, 0.99)
      clusters.agg = sapply(levels(clusters.aggregate) , function(i) {table(as.factor(adult.integrated$cell.type)[clusters.aggregate==i])})
      levels(clusters.aggregate) =   sapply(levels(clusters.aggregate), function(i){
        paste(i, " - ", names(which.max(clusters.agg[,i])), " (", round(100*max(clusters.agg[,i])/sum(clusters.agg[,i]),2), "%)", sep="")
      })
      
  adult.integrated$clusters.aggregate = clusters.aggregate
  
# And we save the adult.integrated object for downsampling in the future
  saveRDS(adult.integrated, "/mnt/LocalHDD/raw_data/I_Adult_Foetal/RDS_files/adult.integrated_feb2021.rds")
```
\normalsize

# Overall summary for part 2
We have produced two objects, found in the manuscript represented by figures 1E and 1F which are to be downsampled using the stratified
sampling strategy in part 3 of the report. The factors to be stratified in foetal data are the foetal clusters, formed partially by the classifier and 
subclustering of the "messy" fibroblast conglomerate found in the foetal integrated dataset (called "foetal.clusters", in the object 
**foetal.integrated**). The adult dataset stratifications instead are formed by the previous **cell.state** annotations, found in the **adult.integrated**
object.





